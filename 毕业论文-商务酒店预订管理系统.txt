\
                                                      密级：
NANCHANG  UNIVERSITY
 学 士 学 位 论 文
THESIS  OF  BACHELOR
（XXXX—XXXX年）

 题   目          基于B/S架构的商务酒店预订管理系统的设计与实现

   学    院：         XXXX学院
   专业班级：      XXXXXXXX专业XXXX级
   学生姓名：    XXX      学号：   XXXXXXXXXX
   指导教师：    XXX      职称：    XXXX
   起讫日期：        XXXX.XX.XX-XXXX.XX.XX

摘要

随着信息技术的浪潮席卷全球，酒店行业也迎来了数字化转型的契机。传统的酒店运营模式，在效率和顾客体验上，似乎总有些力不从心。如何才能让酒店管理更加得心应手，让顾客的每一次预订与入住都如丝般顺滑呢？这便是我在本次毕业设计中所探寻和实践的核心命题——构建一个基于B/S架构的现代化商务酒店预订管理系统。

本项目旨在运用主流的前后端分离技术栈，打造一个功能全面、操作便捷、体验友好的酒店业务管理平台。我们选择了稳健的Spring Boot作为后端服务的坚实骨架，通过Spring Security与JWT令牌技术，为系统的每一次交互保驾护航；数据持久化则交给了Spring Data JPA与MySQL，确保信息的安全与高效存取。而在用户看得见、摸得着的前端，我们拥抱了Vue 3的生态，借助Vite的极速构建、Pinia的状态管理以及Element Plus的精美组件，精心雕琢出直观易用的用户界面，无论是PC端还是移动设备，都能获得流畅的操作感受。

在这个系统中，我们精心设计并实现了多角色协同工作的业务流程。无论是运筹帷幄的酒店管理员，忙碌于前线的接待人员，辛勤付出的清洁团队，还是尊贵的顾客，都能拥有专属的操作界面与权限。从琳琅满目的房型展示、实时的房态更新，到便捷的在线预订、快速的入住登记、清晰的订单管理，再到高效的清洁任务分配与跟踪，以及不可或缺的访客登记和会员体系，我们力求覆盖酒店日常运营的每一个关键环节。更值得一提的是，系统还融入了数据统计与可视化功能，期望能为酒店的经营决策提供一些有价值的参考。

在整个设计与实现的过程中，我深刻体会到，一个优秀的管理系统不仅仅是冰冷代码的堆砌，它更应该承载着对业务流程的深刻理解和对用户体验的极致追求。我们努力让技术的严谨与人文的关怀在这个系统中交汇，希望它不仅仅是一个工具，更能成为提升酒店服务品质、优化管理效率的得力助手。当然，探索永无止境，系统虽已初具雏形，但仍有诸多可完善之处，这也为我未来的学习和研究指明了方向。希望本次的设计与实践，能为相关领域的研究与应用，贡献一份绵薄之力。

关键词：商务酒店；预订管理系统；B/S架构；Spring Boot；Vue；前后端分离；用户体验

Abstract
Keyword: Business Hotel; Reservation Management System; B/S Architecture; Spring Boot; Vue; MySQL

目录

第一章 绪论

1.1 研究背景与意义

1.1.1 研究背景
在信息时代的滚滚浪潮中，互联网如同空气和水一般，渗透到我们生活的角角落落，也以前所未有的力量重塑着各行各业的生态格局。酒店，这个承载着人们差旅休憩、商务洽谈、休闲度假需求的传统行业，正面临着一场深刻的数字化变革。传统的酒店管理方式，往往依赖于人工记录、电话预订、前台手动操作，不仅效率低下，容易出错，更难以满足现代消费者对便捷、高效、个性化服务的殷切期望。尤其是在商务出行日益频繁、个性化旅游需求不断增长的今天，如何提升运营效率、优化顾客体验、在激烈的市场竞争中占据一席之地，成为了摆在每一位酒店经营者面前的现实课题。

想象一下，旅客们在结束了一天的疲惫奔波后，渴望的是一个温馨舒适的港湾，而不是繁琐的入住手续；商务人士在紧张的行程中，需要的是一个能快速响应、精准满足其需求的预订平台，而不是反复的电话沟通和不确定的等待。与此同时，酒店管理者也迫切需要一个能够整合客房资源、实时掌握房态、精准分析运营数据、高效管理人事与财务的智能系统，从而摆脱传统模式的束缚，将更多精力投入到提升服务质量和创新经营模式上。

正是基于这样的时代背景和行业痛点，开发一套现代化的、基于信息技术的酒店管理系统，便显得尤为重要和迫切。尤其是基于B/S（浏览器/服务器）架构的系统，凭借其部署便捷、维护成本低、用户端无需安装专用软件、跨平台兼容性好等天然优势，成为了酒店管理系统升级换代的理想选择。这样的系统，不仅能为顾客提供7x24小时不间断的在线预订服务，还能为酒店内部管理带来前所未有的便捷与高效。这，也正是我们本次毕业设计——"基于B/S架构的商务酒店预订管理系统"的出发点和立足点。我们希望通过技术的赋能，为酒店行业的数字化转型贡献一份力量，让科技的光芒照亮酒店管理的每一个细节。

1.1.2 研究意义
一个精心设计的商务酒店预订管理系统，其意义远不止于提升效率那么简单，它更像是一座桥梁，连接着酒店与顾客，也连接着传统与未来。

首先，对于提升酒店的核心竞争力而言，意义重大。在这个"体验为王"的时代，顾客的每一次互动，从最初的网页浏览、房型比较，到便捷的在线预订、流畅的入住体验，乃至离店后的评价反馈，都直接影响着酒店的口碑和顾客的忠诚度。一个优秀的管理系统，能够显著优化这些触点，提升顾客满意度，从而在激烈的市场竞争中赢得先机。试想，当竞争对手还在为手忙脚乱的前台操作而烦恼时，您的酒店已经可以通过系统轻松应对预订高峰，这是何等的优势！

其次，对于酒店运营管理的精细化和智能化，具有不可替代的推动作用。系统能够实时更新房态信息，避免超售或空置浪费；能够精准记录客户数据，为个性化服务和精准营销提供支持；能够自动化处理部分日常事务，解放人力，让员工有更多时间投入到更有价值的服务创新中。更重要的是，系统沉淀下来的海量运营数据，经过挖掘与分析，能够转化为洞察市场趋势、优化资源配置、提升盈利能力的宝贵"情报"。这对于酒店的可持续发展而言，无疑是一笔巨大的财富。

再者，从技术实践和人才培养的角度来看，本项目也具有积极的现实意义。通过对这样一个完整系统的设计与实现，我们能够将课堂上学到的理论知识与行业实际需求紧密结合，全面提升在软件工程、数据库设计、Web开发、项目管理等方面的综合能力。这不仅仅是一次毕业设计，更是一次宝贵的练兵机会，为我们未来投身于信息技术行业打下了坚实的基础。

最后，放眼整个酒店行业乃至服务业的数字化进程，本研究也希望能起到一定的示范和借鉴作用。我们期望通过分享项目的设计思路、技术选型和实现经验，为其他类似系统的开发提供有益的参考，共同推动行业的整体进步。毕竟，技术的魅力就在于分享与传承，不是吗？

1.2 国内外研究现状

酒店管理信息化并非一个全新的概念，国内外学者和业界对此早已进行了广泛的研究与实践。

1.2.1 国外研究现状
在国外，尤其是在欧美等发达国家，酒店信息化起步较早，发展也更为成熟。大型国际连锁酒店集团，如万豪（Marriott）、希尔顿（Hilton）、洲际（IHG）等，早已投入巨资构建了自身强大且完善的中央预订系统（CRS）、物业管理系统（PMS）以及客户关系管理（CRM）。这些系统通常功能非常复杂，集成了全球范围内的酒店资源，支持多语言、多货币，并与GDS（全球分销系统）、OTA（在线旅行社）等渠道紧密对接。

国外的研究更侧重于以下几个方面：
- 智能化与个性化推荐：利用大数据分析和人工智能技术，为顾客提供更加精准的房型推荐、增值服务推荐，甚至是个性化的房价策略。例如，通过分析用户的历史消费习惯、浏览行为等，预测其潜在需求。
- 移动化与无接触服务：随着智能手机的普及，移动App、移动网站、自助入住/退房终端等成为了提升顾客体验的重要手段。无钥匙进入、在线选房、通过App控制客房设施等技术也逐渐得到应用。
- 收益管理（Revenue Management）：通过复杂的算法模型，根据市场需求、竞争对手动态、季节性因素、顾客细分等，动态调整房价和库存分配，以实现收益最大化。
- 系统集成与数据共享：强调PMS、CRS、CRM以及餐饮、娱乐等其他业务系统之间的数据集成与共享，打破信息孤岛，形成统一的客户视图和运营视图。
- 云计算与SaaS模式：越来越多的中小型酒店开始采用基于云计算的SaaS（软件即服务）模式的酒店管理系统，以降低初期的IT投入和运维成本。

知名的国外酒店管理系统软件供应商包括Oracle Hospitality (Opera PMS就是其旗下产品), Sabre Hospitality Solutions, Amadeus Hospitality等。他们的产品功能强大，但通常价格昂贵，且对于国内一些中小型商务酒店而言，可能存在功能冗余或本土化不足的问题。

1.2.2 国内研究现状
国内酒店管理信息化的起步相对较晚，但发展速度迅猛，尤其是在"互联网+"战略的推动下，涌现出一大批本土的酒店管理系统供应商和服务商。早期的国内系统多模仿国外成熟产品，功能相对基础，主要集中在客房管理、前台接待、收银等核心环节。

近年来，国内的研究和实践呈现出以下特点：
- OTA的深度影响与直销渠道的建设：携程、美团、飞猪等OTA平台在国内酒店预订市场占据主导地位，酒店在依赖OTA获取客源的同时，也越来越重视建设自己的官方网站、微信小程序等直销渠道，以降低佣金成本，提升品牌掌控力。因此，能够与OTA高效对接，并支持多渠道营销的管理系统备受青睐。
- 移动支付与社交化营销的融合：微信支付、支付宝等移动支付方式已成为主流，酒店管理系统需要无缝对接这些支付渠道。同时，利用微信公众号、小程序等社交平台进行客户互动、会员管理、营销推广也成为常态。
- 中小型酒店的信息化需求：国内存在大量的中小型单体酒店和经济型连锁酒店，他们对管理系统的性价比、易用性、以及快速部署能力有较高要求。因此，功能适度、价格亲民、操作便捷的SaaS系统在国内市场有较大空间。
- 智能化硬件的尝试性引入：智能门锁、自助入住机、客房智能控制面板、送物机器人等智能化硬件开始在部分国内酒店试点应用，管理系统需要具备与这些硬件集成的能力。
- 数据安全与合规性重视：随着《网络安全法》、《个人信息保护法》等法律法规的实施，酒店管理系统在数据采集、存储、使用等方面的合规性日益受到重视。

国内知名的酒店管理系统品牌有石基信息、绿云、众荟信息、别样红等。他们针对国内酒店的特点和需求，提供了不同层次的解决方案。但总体而言，与国际顶尖系统相比，在技术深度、功能全面性、尤其是在高级收益管理和智能化个性化服务方面，仍有提升空间。

综合来看，无论是国内还是国外，酒店管理系统都在朝着更加集成化、智能化、移动化和个性化的方向发展。对于本系统而言，立足于B/S架构，采用成熟的前后端分离技术，实现酒店核心业务流程的管理，并考虑一定的扩展性和易用性，既是对现有技术的应用整合，也是对行业发展趋势的一次积极响应。

1.3 主要研究内容
本毕业设计的主要研究内容是设计与实现一个基于B/S架构的商务酒店预订管理系统。具体研究内容将围绕以下几个核心方面展开：

1.  系统需求分析：深入调研商务酒店的实际运营流程和管理需求，明确系统所需具备的各项功能。这包括对不同用户角色（如顾客、前台接待、酒店管理员、清洁人员）的操作需求进行细致分析，以及对系统的性能、安全、易用性等非功能性需求进行定义。
2.  系统总体架构设计：选择合适的技术架构和开发框架。本项目拟采用B/S三层架构，后端基于Spring Boot框架，利用其快速开发、易于集成的特性；前端采用Vue.js框架，实现前后端分离，提升用户体验和开发效率。同时，设计系统的模块划分，明确各模块之间的接口和数据交互方式。
3.  数据库设计：根据系统功能需求，设计合理的数据库结构。这包括概念结构设计（如E-R图）和逻辑结构设计（具体的表、字段、主外键关系、索引等）。数据库选用MySQL，需要确保数据存储的完整性、一致性和查询效率。
4.  核心功能模块的详细设计与实现：
    - 用户管理模块：实现用户的注册、登录、个人信息修改、密码管理以及多角色权限控制（基于Spring Security和JWT）。
    - 房型与房间管理模块：实现酒店管理员对房型信息（如价格、设施、图片）、房间信息（如房号、状态）的增、删、改、查操作。
    - 在线预订模块：实现顾客在线浏览房型、查询房间可用性、选择入住离店日期、填写预订信息、生成预订订单等功能。
    - 入住与退房管理模块：实现前台人员为顾客办理入住登记、分配房间、记录押金、处理退房结算等操作。
    - 清洁任务管理模块：实现清洁任务的生成、分配给清洁人员、清洁状态的更新与跟踪。
    - 访客登记模块：实现对来访酒店客人的信息进行登记和管理。
    - 统计分析模块：对酒店的入住率、营收等关键指标进行统计，并以图表等形式进行可视化展示，为酒店决策提供数据支持。
5.  系统测试：对开发完成的系统进行全面的功能测试、性能测试（简要）、兼容性测试等，确保系统能够稳定、正确地运行，满足设计要求。撰写测试用例，记录测试结果，并对发现的问题进行修复。
6.  论文撰写：按照学术论文的规范，详细阐述系统的研究背景、需求分析、系统设计、实现过程、测试结果以及总结与展望。

通过以上研究内容的逐步推进，旨在构建一个实用、高效、可靠的商务酒店预订管理系统，并在此过程中深化对相关技术和软件工程方法的理解与应用。

1.4 论文组织结构
本论文将严格按照软件工程的开发流程和学术论文的撰写规范，对基于B/S架构的商务酒店预订管理系统的设计与实现过程进行详细阐述。论文的组织结构如下：

第一章：绪论
本章主要介绍项目的研究背景、选题意义以及国内外酒店管理系统的研究现状。同时，明确本论文的主要研究内容和整体的组织结构，为全文的展开奠定基础。

第二章：相关技术介绍
本章将对项目开发过程中所采用的关键技术进行简要介绍。主要包括B/S架构的原理与特点、Java编程语言、Spring Boot后端框架、Vue.js前端框架、MySQL关系型数据库、Maven项目管理工具以及RESTful API设计风格等，使读者对系统所依赖的技术栈有一个清晰的认识。

第三章：系统需求分析
本章是系统设计与实现的前提和依据。首先进行项目的可行性分析，包括技术可行性、经济可行性和操作可行性。然后，详细阐述系统的功能性需求，根据酒店业务流程和用户角色（游客、注册用户、酒店管理员等）定义各个功能模块的具体需求。最后，对系统的非功能性需求，如性能、安全、易用性、可维护性等进行说明。

第四章：系统设计
本章重点阐述系统的整体架构设计和详细设计。首先介绍系统的总体架构（B/S三层架构）和技术选型。其次，对系统的核心功能模块进行详细设计，包括前台用户界面模块（如用户注册登录、房间预订等）和后台管理模块（如用户管理、房间管理、订单管理等）。最后，进行数据库设计，包括数据库的概念结构设计（E-R图）和逻辑结构设计（具体的表结构定义）。

第五章：系统实现
本章将具体描述系统的编码实现过程。首先介绍开发环境的搭建与配置。然后，选取核心功能模块（如用户注册与登录认证、房间预订流程、后台房间管理等），结合关键代码片段，详细说明其后端业务逻辑实现（Controller、Service、Repository）和前端界面交互实现（Vue组件、API调用）。同时，也会对项目中采用的一些关键技术点（如JWT认证、前后端数据交互等）的实现进行阐述。

第六章：系统测试
本章主要介绍对开发完成的系统所进行的各项测试工作。包括测试目的、测试策略、测试环境的搭建。详细描述功能测试的过程，包括核心模块的测试用例设计及执行结果。此外，还会简要提及兼容性测试和性能测试的情况。最后对测试结果进行分析与总结。

第七章：总结与展望
本章是对整个毕业设计工作的总结。回顾系统完成的主要工作内容和取得的成果，分析系统存在的创新点以及尚存的不足之处。最后，对系统的未来优化方向和进一步的研究工作进行展望。

参考文献
列出在论文撰写过程中引用的相关学术文献、技术文档和网络资源。

致谢
向在毕业设计及论文撰写过程中给予指导和帮助的老师、同学以及其他相关人士表示感谢。

第二章 相关技术介绍
    2.1 B/S架构
    2.2 Java编程语言
    2.3 Spring Boot框架
    2.4 Vue.js框架
    2.5 MySQL数据库
    2.6 Maven项目管理工具
    2.7 RESTful API设计风格

第三章 系统需求分析
    3.1 可行性分析
        3.1.1 技术可行性
        3.1.2 经济可行性
        3.1.3 操作可行性
    3.2 功能需求分析
        3.2.1 用户账户管理模块需求
        3.2.2 用户信息管理模块需求
        3.2.3 房间预订模块需求
        3.2.4 入住管理模块需求
        3.2.5 人员来访登记模块需求
        3.2.6 酒店信息展示模块需求
        3.2.7 统计分析模块需求
    3.3 非功能需求分析
        3.3.1 系统性能需求
        3.3.2 系统安全性需求
        3.3.3 系统可维护性需求
        3.3.4 系统易用性需求
    3.4 系统角色分析
        3.4.1 游客（未登录用户）
        3.4.2 注册用户（顾客）
        3.4.3 酒店管理员
    3.5 系统用例分析
        3.5.1 注册用户用例图
        3.5.2 酒店管理员用例图

第四章 系统设计
    4.1 系统总体架构设计
        4.1.1 系统架构图 (B/S三层架构)
        4.1.2 技术选型
    4.2 功能模块设计
        4.2.1 前台功能模块设计
            4.2.1.1 用户注册登录模块
            4.2.1.2 酒店及房间信息展示模块
            4.2.1.3 房间预订模块
            4.2.1.4 个人中心模块 (订单管理、个人信息修改等)
        4.2.2 后台管理功能模块设计
            4.2.2.1 用户管理模块 (顾客账户管理)
            4.2.2.2 酒店及房间管理模块
            4.2.2.3 订单管理模块
            4.2.2.4 入住与退房管理模块
            4.2.2.5 访客登记管理模块
            4.2.2.6 统计报表模块
    4.3 数据库设计
        4.3.1 数据库概念结构设计 (E-R图)
            概念结构设计阶段的目标是从用户需求出发，抽象出系统中的核心信息实体及其相互之间的联系，形成独立于具体数据库管理系统的概念模型。本阶段通常采用实体-联系图（Entity-Relationship Diagram, E-R图）来直观表示。

            根据对酒店业务流程和系统功能需求的分析，并结合实际数据库结构的探查，我们识别出本系统的主要实体及其关系如下：

            **核心实体：**
            -   **用户 (User)**：系统的使用者，包含顾客和不同角色的酒店员工（管理员、前台、清洁员等）。主要属性包括：用户ID(PK), 用户名, 密码, 姓名, 手机号, 邮箱, 角色, 状态, 会员等级信息, 积分等。
            -   **房型 (RoomType)**：酒店提供的房间类型。主要属性包括：房型ID(PK), 名称, 描述, 基础价格, 容量, 设施等。
            -   **房间 (Room)**：酒店内的具体物理房间。主要属性包括：房间ID(PK), 房间号, 楼层, 状态, 所属房型ID(FK)。
            -   **预订 (Reservation)**：顾客预订房间的记录。主要属性包括：预订ID(PK), 订单号, 预订用户ID(FK), 预订房型ID(FK), 预订房间ID(FK, 可空), 入住/离店日期, 总价, 订单状态等。
            -   **入住记录 (CheckInRecord)**：顾客实际入住酒店的记录。主要属性包括：入住记录ID(PK), 关联预订ID(FK, 可空), 入住房间ID(FK), 主要客人信息, 实际入住/离店时间, 费用等。
            -   **清洁记录/任务 (CleaningRecord/Task)**：房间的清洁安排与执行情况。主要属性包括：记录/任务ID(PK), 关联房间ID(FK), 清洁员ID(FK, 可空), 任务状态, 时间等。
            -   **访客记录 (VisitorRecord)**：记录外部人员访问住店客人的信息。主要属性包括：记录ID(PK), 访客姓名, 被访用户ID(FK)/房号, 来访时间, 离开时间等。
            -   **酒店信息 (HotelInfo)**：存储酒店的基本配置信息（通常为单条记录）。
            -   **会员相关实体**：如消费记录 (ConsumptionRecord), 积分记录 (PointsExchangeRecord, PointsExpiryRecord), 等级变更记录 (MemberLevelChangeRecord) 等，都与用户实体关联。

            **主要关系（用文字描述，1代表"一"，N代表"多"）：**
            -   **用户(User) 与 预订(Reservation)**：一个用户可以发起多个预订 (1对N)。一个预订属于一个用户。
                `User --< Reservation`
            -   **房型(RoomType) 与 房间(Room)**：一个房型下可以有多个房间 (1对N)。一个房间属于一个特定的房型。
                `RoomType --< Room`
            -   **房间(Room) 与 预订(Reservation)**：一个房间可以在不同时间被多次预订 (1对N)。一个预订通常对应一个房间（或一个房型下的可用房间）。
                `Room >--< Reservation` (关系较复杂，预订时可能只关联房型，入住时分配具体房间，或一个预订对应多个房间实例，这里简化表示)
            -   **房间(Room) 与 清洁记录(CleaningRecord/Task)**：一个房间可以有多条清洁记录/任务 (1对N)。一条清洁记录/任务对应一个房间。
                `Room --< CleaningRecord/Task`
            -   **用户(User) 与 清洁记录(CleaningRecord/Task)**：一个清洁员（用户）可以执行多条清洁记录/任务 (1对N)。一条清洁记录/任务可以分配给一个清洁员。
                `User --< CleaningRecord/Task` (作为清洁员)
            -   **预订(Reservation) 与 入住记录(CheckInRecord)**：一个预订通常对应一个入住记录 (1对1或1对0..1)。一个入住记录可以基于一个预订生成，也可以是无预订的散客入住。
                `Reservation >-- CheckInRecord` (虚线表示可选关联)
            -   **房间(Room) 与 入住记录(CheckInRecord)**：一个房间可以有多条入住记录（不同时间）(1对N)。一个入住记录对应一个房间。
                `Room --< CheckInRecord`
            -   **用户(User) 与 入住记录(CheckInRecord)**：一个用户（作为住客）可以有多条入住记录 (1对N)。一个入住记录关联一个或多个住客。
                `User --< CheckInRecord` (作为住客)
            -   **用户(User) 与 访客记录(VisitorRecord)**：一个用户（作为被访者）可以有多条访客记录 (1对N)。一个访客记录对应一个被访者。
                `User --< VisitorRecord` (作为被访者)
            -   **用户(User) 与 会员相关记录**：用户与其消费记录、积分记录、等级变更记录等通常是1对N的关系。
                `User --< ConsumptionRecord`
                `User --< PointsExchangeRecord`
                `User --< PointsExpiryRecord`
                `User --< MemberLevelChangeRecord`
            -   **入住记录(CheckInRecord) 与 额外费用(AdditionalCharge)**：一个入住记录可以产生多条额外费用记录 (1对N)。
                `CheckInRecord --< AdditionalCharge`
            -   **入住记录(CheckInRecord) 与 同行访客(Visitor)**：一个入住记录可以关联多个同行访客/住客信息 (1对N，根据`visitors`表与`check_in_records`的外键推断)。
                `CheckInRecord --< Visitor`

            (注：以上关系描述基于数据库外键和业务逻辑推断，更详细和精确的关系应在后续的逻辑结构设计或详细的E-R图中体现。例如，多对多关系需要中间表。)

            通过构建E-R图（此处用文字描述替代），我们可以清晰地表达系统的数据结构和实体间的逻辑关联，为后续的数据库逻辑结构设计（表结构设计）提供了坚实的基础和清晰的指引。

        4.3.2 数据库逻辑结构设计 (表结构)
            数据库表设计是数据库设计的核心环节，其合理性直接影响数据库的性能和系统的稳定性。本系统根据功能需求和模块划分，设计了以下主要数据表：

            4.3.2.1 用户表 (users)
            用户表用于存储所有系统用户的信息，包括顾客、前台、清洁人员和管理员。
            表4-1 用户表 (users)
            | 字段名称        | 数据类型          | 约束/索引     | 说明             |
            |-----------------|-------------------|---------------|------------------|
            | id              | BIGINT            | 主键, 自增    | 用户唯一标识符     |
            | username        | VARCHAR(255)      | 非空, 唯一    | 用户登录名       |
            | password        | VARCHAR(255)      | 非空          | 加密后的登录密码   |
            | name            | VARCHAR(255)      | 非空          | 用户真实姓名     |
            | phone           | VARCHAR(255)      |               | 联系电话         |
            | email           | VARCHAR(255)      | 非空          | 电子邮箱         |
            | gender          | VARCHAR(255)      |               | 性别             |
            | birthday        | DATE              |               | 出生日期         |
            | id_type         | VARCHAR(255)      |               | 证件类型 (枚举)  |
            | id_number       | VARCHAR(255)      |               | 证件号码         |
            | role            | VARCHAR(255)      | 非空          | 用户角色 (枚举)  |
            | status          | VARCHAR(20)       | 非空, 默认ACTIVE | 账户状态 (如ACTIVE, DISABLED) |
            | member_level    | VARCHAR(255)      | 非空, 默认REGULAR | 会员等级 (枚举)  |
            | points          | INT               | 非空, 默认0   | 会员积分         |
            | total_spent     | DECIMAL(10,2)     | 非空, 默认0.00 | 累计消费金额     |
            | create_time     | DATETIME          |               | 记录创建时间     |
            | update_time     | DATETIME          |               | 记录更新时间     |

            4.3.2.2 角色表 (roles) - (根据实际情况，User表中的role字段可能已满足需求，若有独立角色权限管理则需此表)
            角色表定义了系统中的不同用户角色及其权限。
            表4-2 角色表 (roles)
            | 字段名称    | 数据类型       | 约束/索引  | 说明         |
            |-------------|----------------|------------|--------------|
            | id          | BIGINT         | 主键, 自增 | 角色ID       |
            | name        | VARCHAR(255)   | 非空, 唯一 | 角色名称     |
            | description | VARCHAR(255)   |            | 角色描述     |
            | create_time | DATETIME       |            | 创建时间     |
            | update_time | DATETIME       |            | 更新时间     |

            4.3.2.3 权限表 (permissions) - (若有细粒度权限控制则需要)
            权限表定义了系统中各项操作的权限。
            表4-3 权限表 (permissions)
            | 字段名称    | 数据类型       | 约束/索引  | 说明         |
            |-------------|----------------|------------|--------------|
            | id          | BIGINT         | 主键, 自增 | 权限ID       |
            | name        | VARCHAR(255)   | 非空, 唯一 | 权限名称     |
            | code        | VARCHAR(255)   | 非空, 唯一 | 权限代码 (如: user:create) |
            | description | VARCHAR(255)   |            | 权限描述     |
            | create_time | DATETIME       |            | 创建时间     |
            | update_time | DATETIME       |            | 更新时间     |
            (角色权限关联表 t_role_permission 可能也需要)

            4.3.2.4 酒店信息表 (hotel_info)
            存储酒店的基本信息。
            表4-4 酒店信息表 (hotel_info)
            | 字段名称      | 数据类型        | 约束/索引  | 说明           |
            |---------------|-----------------|------------|----------------|
            | id            | BIGINT          | 主键, 自增 | ID             |
            | name          | VARCHAR(255)    | 非空       | 酒店名称       |
            | address       | VARCHAR(255)    |            | 酒店地址       |
            | phone         | VARCHAR(255)    |            | 联系电话       |
            | email         | VARCHAR(255)    |            | 电子邮箱       |
            | description   | TEXT            |            | 酒店描述       |
            | check_in_time | VARCHAR(255)    |            | 标准入住时间   |
            | check_out_time| VARCHAR(255)    |            | 标准退房时间   |
            | logo_url      | VARCHAR(255)    |            | 酒店Logo URL   |
            | images        | TEXT            |            | 酒店图片 (JSON) |
            | policies      | TEXT            |            | 酒店政策 (JSON) |
            | create_time   | DATETIME        |            | 创建时间       |
            | update_time   | DATETIME        |            | 更新时间       |

            4.3.2.5 房间类型表 (room_types)
            存储酒店提供的不同房间类型的信息。
            表4-5 房间类型表 (room_types)
            | 字段名称          | 数据类型        | 约束/索引  | 说明                 |
            |-------------------|-----------------|------------|----------------------|
            | id                | BIGINT          | 主键, 自增 | 房型ID               |
            | name              | VARCHAR(255)    | 非空       | 房型名称 (如豪华大床房)|
            | description       | VARCHAR(255)    |            | 简短描述             |
            | long_description  | TEXT            |            | 详细描述             |
            | base_price        | DECIMAL(10,2)   | 非空       | 基础价格             |
            | weekend_price     | DECIMAL(10,2)   |            | 周末价格             |
            | holiday_price     | DECIMAL(10,2)   |            | 节假日价格           |
            | capacity          | INT             | 非空       | 标准入住人数         |
            | max_capacity      | INT             |            | 最大入住人数(含加床) |
            | extra_bed_price   | DECIMAL(10,2)   |            | 加床价格             |
            | bed_type          | VARCHAR(255)    |            | 床型 (如: 大床, 双床) |
            | bed_size          | VARCHAR(255)    |            | 床尺寸               |
            | area              | INT             |            | 房间面积(平方米)     |
            | floor             | VARCHAR(255)    |            | 楼层范围             |
            | amenities         | VARCHAR(1000)   |            | 房间设施 (逗号分隔)  |
            | images            | TEXT            |            | 房型图片 (JSON)      |
            | policies          | TEXT            |            | 预订政策 (JSON)      |
            | create_time       | DATETIME        |            | 创建时间             |
            | update_time       | DATETIME        |            | 更新时间             |

            4.3.2.6 房间信息表 (rooms)
            存储酒店内每个具体房间的信息。
            表4-6 房间信息表 (rooms)
            | 字段名称        | 数据类型        | 约束/索引        | 说明                 |
            |-----------------|-----------------|------------------|----------------------|
            | id              | BIGINT          | 主键, 自增       | 房间ID               |
            | room_number     | VARCHAR(255)    | 非空, 唯一       | 房间号               |
            | room_type_id    | BIGINT          | 非空, 外键(room_types) | 关联的房型ID         |
            | floor           | INT             | 非空             | 所在楼层             |
            | status          | VARCHAR(255)    | 非空, 默认AVAILABLE | 房间状态 (枚举: AVAILABLE, OCCUPIED, RESERVED, MAINTENANCE, CLEANING, NEEDS_CLEANING) |
            | notes           | VARCHAR(1000)   |                  | 备注信息             |
            | need_cleaning   | BOOLEAN         | 默认 FALSE       | 是否需要清洁         |
            | description     | VARCHAR(1000)   |                  | 房间具体描述         |
            | create_time     | DATETIME        |                  | 创建时间             |
            | update_time     | DATETIME        |                  | 更新时间             |

            4.3.2.7 预订订单表 (reservations)
            存储用户的房间预订信息。
            表4-7 预订订单表 (reservations)
            | 字段名称            | 数据类型        | 约束/索引      | 说明                   |
            |---------------------|-----------------|----------------|------------------------|
            | id                  | BIGINT          | 主键, 自增     | 预订ID                 |
            | user_id             | BIGINT          | 非空, 外键(users) | 预订用户ID             |
            | room_id             | BIGINT          | 非空, 外键(rooms) | 预订房间ID (首选房间，若多间房可设计关联表) |
            | guest_name          | VARCHAR(255)    | 非空           | 入住客人姓名           |
            | guest_phone         | VARCHAR(255)    | 非空           | 入住客人电话           |
            | room_count          | INT             | 非空, 默认1    | 预订房间数量           |
            | check_in_time       | DATETIME        | 非空           | 预计入住时间           |
            | check_out_time      | DATETIME        | 非空           | 预计退房时间           |
            | total_price         | DECIMAL(10,2)   | 非空           |订单总价 (基于预订时的价格)|
            | status              | VARCHAR(255)    | 非空           | 预订状态 (枚举: PENDING, CONFIRMED, CHECKED_IN, COMPLETED, CANCELLED) |
            | special_requests    | TEXT            |                | 特殊要求               |
            | payment_status      | VARCHAR(255)    | 非空           | 支付状态 (如: UNPAID, PAID, REFUNDED) |
            | check_in_actual_time| DATETIME        |                | 实际入住时间           |
            | check_out_actual_time| DATETIME       |                | 实际退房时间           |
            | create_time         | DATETIME        |                | 创建时间               |
            | update_time         | DATETIME        |                | 更新时间               |

            4.3.2.8 入住登记表 (check_in_records)
            记录客人的实际入住信息，通常与预订关联，也可处理直接到店客人。
            表4-8 入住登记表 (check_in_records)
            | 字段名称            | 数据类型        | 约束/索引      | 说明                  |
            |---------------------|-----------------|----------------|-----------------------|
            | id                  | BIGINT          | 主键, 自增     | 入住记录ID            |
            | reservation_id      | BIGINT          | 外键(reservations) | 关联的预订ID (可为空) |
            | user_id             | BIGINT          | 外键(users)    | 关联的住客用户ID (可为空, 若非会员) |
            | room_id             | BIGINT          | 非空, 外键(rooms) | 入住房间ID            |
            | guest_name          | VARCHAR(255)    | 非空           | 主要客人姓名          |
            | guest_id_type       | VARCHAR(255)    |                | 客人证件类型          |
            | guest_id_number     | VARCHAR(255)    |                | 客人证件号码          |
            | number_of_guests    | INT             | 非空           | 入住人数              |
            | actual_check_in_time| DATETIME        | 非空           | 实际入住时间          |
            | expected_check_out_time| DATETIME     | 非空           | 预计退房时间          |
            | actual_check_out_time| DATETIME       |                | 实际退房时间          |
            | total_amount        | DECIMAL(10,2)   |                | 实际消费总额 (可能包含额外消费) |
            | deposit             | DECIMAL(10,2)   |                | 押金                  |
            | status              | VARCHAR(255)    | 非空           | 入住状态 (如: CHECKED_IN, CHECKED_OUT) |
            | notes               | TEXT            |                | 备注                  |
            | create_time         | DATETIME        |                | 创建时间              |
            | update_time         | DATETIME        |                | 更新时间              |

            4.3.2.9 访客登记表 (visitor_records)
            记录酒店访客的来访与离开信息。
            表4-9 访客登记表 (visitor_records)
            | 字段名称            | 数据类型        | 约束/索引      | 说明                 |
            |---------------------|-----------------|----------------|----------------------|
            | id                  | BIGINT          | 主键, 自增     | 访客记录ID           |
            | visitor_name        | VARCHAR(255)    | 非空           | 访客姓名             |
            | visitor_phone       | VARCHAR(255)    |                | 访客电话             |
            | visitor_id_number   | VARCHAR(255)    |                | 访客证件号           |
            | visited_guest_name  | VARCHAR(255)    |                | 被访客人姓名         |
            | visited_room_number | VARCHAR(255)    |                | 被访房间号           |
            | visit_reason        | VARCHAR(1000)   |                | 来访事由             |
            | entry_time          | DATETIME        | 非空           | 进入时间             |
            | exit_time           | DATETIME        |                | 离开时间             |
            | accompanying_staff  | VARCHAR(255)    |                | 陪同员工 (前台)      |
            | notes               | TEXT            |                | 备注                 |
            | create_time         | DATETIME        |                | 创建时间             |
            | update_time         | DATETIME        |                | 更新时间             |

            4.3.2.10 清洁记录表 (cleaning_records)
            记录房间的清洁任务和状态。
            表4-10 清洁记录表 (cleaning_records)
            | 字段名称        | 数据类型        | 约束/索引      | 说明               |
            |-----------------|-----------------|----------------|--------------------|
            | id              | BIGINT          | 主键, 自增     | 清洁记录ID         |
            | room_id         | BIGINT          | 非空, 外键(rooms)| 关联的房间ID       |
            | cleaner_id      | BIGINT          | 外键(users)    | 负责清洁员ID       |
            | task_type       | VARCHAR(255)    |                | 清洁类型 (如: 日常,深度)|
            | status          | VARCHAR(255)    | 非空           | 任务状态 (如: PENDING, IN_PROGRESS, COMPLETED) |
            | schedule_time   | DATETIME        |                | 计划清洁时间       |
            | start_time      | DATETIME        |                | 清洁开始时间       |
            | end_time        | DATETIME        |                | 清洁完成时间       |
            | notes           | TEXT            |                | 备注               |
            | create_time     | DATETIME        |                | 创建时间           |
            | update_time     | DATETIME        |                | 更新时间           |
            
            4.3.2.11 会员等级表 (member_levels)
            存储会员等级信息及其权益。
            表4-11 会员等级表 (member_levels)
            | 字段名称        | 数据类型        | 约束/索引      | 说明               |
            |-----------------|-----------------|----------------|--------------------|
            | id              | BIGINT          | 主键, 自增     | 等级ID             |
            | level_name      | VARCHAR(255)    | 非空, 唯一     | 等级名称 (如: 普通会员, 银卡, 金卡) |
            | min_points      | INT             |                | 达到该等级所需最低积分 |
            | min_spent       | DECIMAL(10,2)   |                | 达到该等级所需最低消费 |
            | discount_rate   | DECIMAL(3,2)    | 非空, 默认1.00 | 折扣率 (如0.9表示9折)|
            | description     | TEXT            |                | 等级权益描述       |
            | create_time     | DATETIME        |                | 创建时间           |
            | update_time     | DATETIME        |                | 更新时间           |
            (User实体中已有MemberLevel枚举和totalSpent，此表主要用于定义等级规则和权益，User表存储当前用户等级)

            (其他如支付记录表、评价表、系统日志表等可根据详细需求补充)

第五章 系统实现
    5.1 开发环境与工具配置
        本系统的开发与运行环境主要包括硬件环境、软件环境以及开发工具。合理的配置有助于提高开发效率和系统稳定性。

        5.1.1 软件环境
            操作系统：Windows 10/11, macOS, 或 Linux 发行版
            Java开发工具包 (JDK)：Java 17 (根据README.md)
            Web服务器：内置于Spring Boot (通常是Tomcat)
            数据库服务器：MySQL 8.0+ (根据README.md)
            项目构建工具：Maven 3.6+ (根据README.md)
            前端环境：Node.js 14+ (根据README.md)
            浏览器：Chrome, Firefox, Safari, Edge 等现代浏览器

        5.1.2 开发工具
            后端集成开发环境 (IDE)：IntelliJ IDEA
            前端集成开发环境 (IDE)：Visual Studio Code
            数据库管理工具：Navicat Premium 或 DBeaver
            版本控制工具：Git
            API测试工具：Postman 或 IntelliJ IDEA HTTP Client 或 Swagger UI
    5.2 核心功能模块实现
        5.2.1 用户注册与登录模块实现 (前端与后端)
        5.2.2 房间预订流程实现 (前端与后端)
        5.2.3 后台管理员房间管理功能实现
        5.2.4 (其他关键模块的实现，结合代码)
    5.3 关键技术点实现
        5.3.1 Spring Boot后端API接口设计与实现
        5.3.2 Vue.js前端组件化开发与数据交互
        5.3.3 统计图表生成与展示

第六章 系统测试
    6.1 测试目的与测试策略
    6.2 测试环境
    6.3 功能测试
        6.3.1 测试用例设计原则
        6.3.2 用户注册登录功能测试用例
        6.3.3 房间预订功能测试用例
        6.3.4 后台管理功能测试用例 (如房间增删改查)
    6.4 兼容性测试
    6.5 性能测试 (简要)
    6.6 测试结果分析与总结

第七章 总结与展望
    7.1 系统主要工作总结
    7.2 系统创新点与不足
    7.3 未来工作展望

参考文献

致谢 

第二章 相关技术介绍

一个成功的软件项目，离不开稳定、高效、成熟的技术栈作为支撑。本项目"基于B/S架构的商务酒店预订管理系统"在技术选型上，综合考虑了开发效率、系统性能、可维护性以及未来扩展性等多方面因素，最终选择了一系列业界主流且经过广泛验证的技术。本章将对这些核心技术进行简要介绍，以便读者更好地理解系统的构建基础。

2.1 B/S架构
B/S架构，即浏览器/服务器（Browser/Server）架构，是当今Web应用开发中广泛采用的一种网络结构模式。顾名思义，它将系统的功能模块主要集中在服务器端，客户端则通过标准的Web浏览器来访问和使用系统。这种架构与传统的C/S（客户端/服务器）架构相比，展现出了诸多引人注目的优势：
-   部署与维护便捷：系统升级和维护主要在服务器端进行，客户端无需单独安装或更新特定软件，用户打开浏览器即可访问最新版本的系统，这大大降低了部署和维护的复杂度和成本。想象一下，当系统需要一个小小的调整，我们不必再麻烦每一位用户去下载补丁，是不是省心多了？
-   跨平台性良好：只要设备上安装了符合标准的浏览器（如Chrome, Firefox, Edge等），无论是Windows、macOS还是Linux系统，甚至是移动设备，都能无障碍地访问系统，实现了真正的"一次开发，多端运行"。
-   用户体验统一：用户在不同设备上使用相同的浏览器界面，操作习惯得以保持一致。
-   数据集中管理：所有业务数据和逻辑都集中在服务器端处理和存储，有利于数据的统一管理、备份和安全保障。

当然，B/S架构对服务器的性能和网络带宽有一定要求，并且在处理复杂交互和本地资源访问方面可能不如C/S架构灵活。但对于酒店管理这类信息管理和在线服务系统而言，B/S架构的优势远大于其局限性，是构建现代化、易用型应用系统的理想选择。

2.2 Java编程语言
Java，这门由Sun Microsystems（现为Oracle公司）于1995年推出的高级编程语言，凭借其"一次编写，到处运行"（Write Once, Run Anywhere）的跨平台特性、强大的面向对象编程能力、健壮的内存管理机制（如垃圾回收GC）、以及庞大而活跃的开源生态系统，早已成为企业级应用开发领域的常青树。选择Java作为本系统后端服务的主要开发语言，主要基于以下考量：
-   成熟稳定：Java语言本身及其虚拟机（JVM）经过了数十年的发展和大规模应用验证，表现出极高的稳定性和可靠性，能够支撑酒店管理系统7x24小时不间断运行的需求。
-   生态丰富：围绕Java有着海量的开源框架、库和工具，例如我们后面会提到的Spring Boot、Spring Data JPA等，这些成熟的轮子极大地提高了开发效率，避免了重复劳动。遇到问题时，也能轻易地从庞大的开发者社区中找到解决方案。
-   面向对象：Java的面向对象特性（封装、继承、多态）使得代码结构更加清晰，模块化程度更高，易于理解、维护和扩展。这对于构建一个功能模块众多的酒店管理系统尤为重要。
-   高性能与高并发处理能力：Java虚拟机通过即时编译（JIT）等技术不断优化性能，并且Java平台提供了丰富的并发编程工具（如线程池、并发集合等），能够较好地应对未来可能出现的并发访问压力。

虽然Java有时会因其相对的"重量级"而受到一些讨论，但其在大型、复杂、高可靠性系统构建中的综合优势依然难以替代。

2.3 Spring Boot框架
如果说Java是构建大厦的钢筋水泥，那么Spring Boot框架无疑就是那个能让我们快速、高效、优雅地搭建起这座大厦的现代化施工队。Spring Boot是由Pivotal团队提供的全新框架，其设计目标是用来简化新Spring应用的初始搭建以及开发过程。它巧妙地运用了"约定优于配置"的理念，为开发者做了大量的自动化配置工作，让我们能够更加专注于业务逻辑的实现，而不是深陷于繁琐的XML配置泥潭。
-   快速启动与简化配置：Spring Boot提供了大量的"起步依赖"（Starters），例如`spring-boot-starter-web`用于Web开发，`spring-boot-starter-data-jpa`用于数据库访问。我们只需要在项目的`pom.xml`（如果是Maven项目）中引入相应的起步依赖，Spring Boot就会自动完成大部分常用库的配置，甚至内嵌了Tomcat、Jetty等Web服务器，使得我们可以直接将应用打包成一个可执行的JAR文件并独立运行。这感觉就像是拿到了一套预制好的积木，搭建起来自然得心应手！
-   微服务友好：Spring Boot的轻量级和独立运行特性，使其非常适合构建微服务架构。虽然本酒店管理系统初期可能并非严格的微服务拆分，但Spring Boot为未来的架构演进提供了良好的基础。
-   强大的生态集成：Spring Boot与Spring家族的其他项目（如Spring Framework, Spring Security, Spring Data等）无缝集成，同时也方便整合各种第三方库。
-   监控与管理：通过Spring Boot Actuator模块，可以方便地对应用进行监控和管理，例如查看应用健康状况、各项指标、环境变量等。

可以说，Spring Boot的出现，极大地提升了Java Web应用的开发体验和效率，是现代Java后端开发的首选框架之一。

2.4 Vue.js框架
在用户直接感知的前端领域，我们选择了Vue.js（通常简称为Vue）作为构建用户界面的核心框架。Vue是一套用于构建用户界面的渐进式JavaScript框架，由尤雨溪创建。它以其轻量、易学、高效、灵活的特点，在前端社区中广受欢迎。
-   渐进式框架：这意味着我们可以将Vue作为项目的一部分嵌入，也可以用它来构建一个完整的单页面应用（SPA）。对于本酒店管理系统而言，我们构建的是一个SPA，能够提供更加流畅的用户体验，避免了传统多页面应用频繁的页面刷新。
-   数据驱动视图：Vue的核心思想之一是数据驱动。我们只需要关心数据的变化，Vue会自动高效地更新DOM视图，开发者无需直接操作复杂的DOM元素，大大简化了前端逻辑。
-   组件化开发：Vue允许我们将用户界面拆分成一个个独立、可复用的组件（Components）。例如，一个登录表单、一个房间卡片、一个分页控件都可以封装成组件。这种方式不仅提高了代码的复用性，也使得项目结构更加清晰，易于维护和团队协作。
-   丰富的生态系统：Vue拥有一个非常活跃的生态，包括官方的路由管理工具Vue Router、状态管理工具Pinia（Vue 3推荐，取代了Vuex）、以及大量的第三方UI组件库（如本项目使用的Element Plus）和插件。
-   Vite构建工具：在Vue 3时代，Vite作为新一代的前端构建工具，以其闪电般的冷启动速度、极速的模块热更新（HMR）能力，显著提升了开发体验。

通过Vue.js及其生态，我们能够高效地构建出现代化、响应式、交互友好的用户界面，为酒店的各类用户角色提供舒适的操作体验。

2.5 MySQL数据库
数据的存储和管理是任何信息系统的基石。本项目选择MySQL作为后端的数据库管理系统。MySQL是一个开源的关系型数据库管理系统（RDBMS），凭借其高性能、高可靠性、易用性以及广泛的社区支持，成为了Web应用开发中最受欢迎的数据库之一，尤其是对于中小型应用而言。
-   关系型数据库：MySQL遵循关系模型，数据以表（Table）的形式组织，表与表之间可以通过外键建立关联，能够很好地表达酒店业务中各种实体（如用户、房间、订单等）及其之间的复杂关系，保证了数据的一致性和完整性。
-   开源与成本效益：MySQL是开源的，社区版可以免费使用，这对于预算有限的项目或初创企业来说具有很大的吸引力。
-   成熟稳定：MySQL经过了长时间的发展和广泛的应用考验，其稳定性和数据安全性得到了业界的普遍认可。
-   性能良好：对于酒店管理系统这类以事务处理（OLTP）为主的应用场景，MySQL通过其存储引擎（如InnoDB）提供了良好的读写性能和事务支持（ACID特性）。
-   丰富的工具支持：有大量的图形化管理工具（如Navicat, DBeaver, phpMyAdmin）和编程语言接口（如Java的JDBC, Python的PyMySQL）支持MySQL，方便开发和管理。

在本系统中，MySQL将负责存储用户信息、房型房间数据、预订订单、入住记录、访客信息等核心业务数据。通过Spring Data JPA，我们可以用面向对象的方式与MySQL进行交互，进一步简化数据库操作。

2.6 Maven项目管理工具
在Java的世界里，项目的构建、依赖管理、打包、发布等工作，如果完全手动操作，那将是一场噩梦。幸运的是，我们有Maven这样的自动化构建工具。Maven是一个强大的项目管理和综合工具，它基于项目对象模型（POM，Project Object Model）的概念，可以通过一小段描述信息来管理项目的构建、报告和文档。
-   依赖管理：这是Maven最核心的功能之一。我们只需要在项目的`pom.xml`文件中声明项目所需的依赖库（例如Spring Boot的各个模块、数据库驱动、工具类库等）及其版本，Maven就会自动从中央仓库或私有仓库下载这些依赖，并解决它们之间的传递依赖关系。再也不用手动去下载JAR包，然后一个个添加到项目的classpath中了，是不是感觉轻松了不少？
-   标准化的项目结构与构建生命周期：Maven定义了一套标准的项目目录结构（如`src/main/java`, `src/main/resources`, `src/test/java`等）和一套清晰的构建生命周期（如`clean`, `validate`, `compile`, `test`, `package`, `install`, `deploy`）。这使得不同开发者、不同项目之间能够更好地协作，也方便了自动化构建流程的实现。
-   插件化架构：Maven的功能是通过插件来实现的，它拥有大量内置和第三方插件，可以满足各种构建需求，如编译代码、运行单元测试、打包（生成JAR或WAR文件）、生成项目文档等。
-   一致的项目信息管理：`pom.xml`文件集中管理了项目的元数据、依赖、插件配置等信息，使得项目信息更加透明和易于维护。

对于本酒店管理系统后端服务的开发，Maven将扮演着不可或缺的角色，确保项目构建的规范化和自动化。

2.7 RESTful API设计风格
为了实现前后端的分离，后端服务需要提供一套清晰、规范、易于理解和使用的API（应用程序编程接口）供前端或其他客户端调用。本项目在API设计上遵循了RESTful（Representational State Transfer，表述性状态转移）风格。REST是一种针对网络应用的软件架构风格，而不是一个标准。它强调使用标准的HTTP方法（如GET, POST, PUT, DELETE, PATCH等）来操作网络上的资源。
1.  资源（Resource）：REST的核心概念是资源。系统中的每一个实体（如一个用户、一个房间、一个订单）都可以被视为一个资源，并通过URI（统一资源标识符）进行唯一标识。例如，`/api/users/123` 可能表示ID为123的用户资源。
2.  表述（Representation）：客户端与服务器之间传递的是资源的某种表述。例如，一个用户资源的表述可以是JSON格式或XML格式的数据。本项目主要使用JSON作为数据交换格式。
3.  状态转移（State Transfer）：客户端通过HTTP方法对服务器上的资源进行操作，从而实现状态的转移。例如：
    -   `GET /api/rooms`：获取所有房间列表（查询）。
    -   `POST /api/reservations`：创建一个新的预订（新建）。
    -   `PUT /api/rooms/101`：更新ID为101的房间信息（修改，整体替换）。
    -   `DELETE /api/users/123`：删除ID为123的用户（删除）。
4.  无状态（Stateless）：RESTful API通常是无状态的，即服务器不保存客户端的会话状态。每个请求都应该包含所有必要的信息，以便服务器能够理解和处理该请求。这使得系统更易于扩展和缓存。在本系统中，我们通过JWT来实现无状态认证。
5.  统一接口（Uniform Interface）：这是REST的核心原则之一，它简化和解耦了架构，使得各个部分可以独立演进。

遵循RESTful风格设计API，可以使得前后端的职责更加清晰，接口更加规范，易于被不同的客户端（如Web前端、移动App、第三方服务）集成和调用，同时也提升了系统的可维护性和可扩展性。


第三章 系统需求分析

需求分析，这个在软件工程生命周期中占据着举足轻重地位的环节，它就像是建筑师在动工前绘制的蓝图，直接决定了最终建筑能否满足使用者的期望，能否稳固地屹立不倒。对于我们的"商务酒店预订管理系统"而言，详尽而准确的需求分析，更是确保系统实用性、高效性和用户满意度的基石。本章将从可行性分析、功能需求、非功能需求、系统角色以及系统用例等多个维度，对系统的需求进行深入的剖析与阐述。

3.1 可行性分析

在正式投入系统设计与开发之前，进行充分的可行性分析是必不可少的步骤，它能帮助我们评估项目在现有条件下是否具备成功实施的可能，避免盲目投入造成资源浪费。

3.1.1 技术可行性
"工欲善其事，必先利其器。" 技术的选型与成熟度，直接关系到项目能否顺利实现。
-   **后端技术**：本项目后端选用Java语言及Spring Boot框架。Java作为一门成熟稳定、生态丰富的编程语言，拥有大量的开源库和社区支持，足以应对企业级应用的开发需求。Spring Boot则以其"约定优于配置"的理念，极大地简化了Spring应用的搭建和开发过程，内置了Web服务器，并能与Spring Security（安全控制）、Spring Data JPA（数据持久化）等无缝集成。MySQL数据库也是业界广泛应用的关系型数据库，性能稳定可靠。这些技术的组合在国内乃至全球都有着广泛的应用案例和成熟的解决方案，技术门槛相对适中，相关学习资源丰富，开发团队（或个人）完全有能力掌握并应用于项目实践中。
-   **前端技术**：前端选用Vue.js 3配合Vite构建工具，以及Element Plus UI组件库和Pinia状态管理。Vue以其轻量、易学、高效的特性，非常适合构建单页面应用（SPA），提供流畅的用户体验。Element Plus提供了丰富的预设组件，可以大大加速界面的开发。前后端分离的架构模式，使得前后端可以并行开发，职责清晰，也有利于后续的维护与升级。
-   **开发与运行环境**：项目所需的开发工具（如IntelliJ IDEA, VS Code）、版本控制工具（Git）、以及服务器运行环境（如Linux/Windows服务器，JDK, Maven, Node.js）均为常用且易于获取和配置的。

综上所述，从技术层面来看，本项目采用的技术栈成熟、主流，社区支持良好，相关人才储备充足，技术风险较低，具备充分的技术可行性。

3.1.2 经济可行性
经济可行性主要评估项目的成本投入与预期效益。
-   **开发成本**：
    -   硬件成本：开发和测试阶段所需的计算机设备通常为开发者已有，服务器若初期采用云服务器（如阿里云、腾讯云的学生机或按量付费模式），成本也相对可控。
    -   软件成本：本项目所采用的主要技术栈，如Java, Spring Boot, Vue.js, MySQL社区版, Maven, Git等，均为开源或免费软件，无需支付昂贵的商业授权费用。开发工具如IntelliJ IDEA社区版、VS Code也是免费的。
    -   人力成本：对于毕业设计而言，主要的人力投入是开发者自身的时间和精力。如果考虑商业化运营，则需要计算开发人员、测试人员、运维人员的薪资。
-   **运行与维护成本**：系统上线后，主要的运行成本是服务器租赁费用和网络带宽费用。维护成本则包括日常的系统监控、故障排除、数据备份以及根据用户反馈进行的小版本迭代。由于采用了成熟的技术栈和模块化设计，预计维护难度和成本也处于可接受范围。
-   **预期效益**：
    -   对于酒店而言，一个高效的管理系统能够显著提升运营效率（如减少人工操作、优化预订流程、实时房态管理），降低运营成本（如减少人力需求、避免超售或空置造成的损失）。
    -   提升顾客满意度和忠诚度，通过便捷的在线服务和个性化体验吸引更多顾客，从而增加酒店营收。
    -   为管理层提供准确的运营数据分析，辅助科学决策。
    -   对于毕业设计本身，其直接的经济效益可能不明显，但其带来的学术价值、技术能力的提升以及潜在的商业转化可能，都是重要的无形效益。

考虑到毕业设计的性质，以及开源技术的广泛应用，本项目的经济投入主要集中在时间和精力上，经济风险小，具备经济可行性。若未来考虑商业化，其带来的管理效率提升和客户体验改善，有望产生良好的经济回报。

3.1.3 操作可行性
操作可行性主要评估系统建成后，其用户群体是否能够方便、有效地使用系统。
-   **用户界面设计**：系统前端将采用Vue.js和Element Plus UI组件库，力求界面简洁直观、交互友好。我们会参考主流Web应用的设计规范，确保不同文化背景和计算机操作水平的用户都能较快上手。例如，清晰的导航、一致的操作逻辑、必要的提示信息等。
-   **角色权限划分**：系统将根据酒店内部的不同岗位（如前台、管理员、清洁人员）和外部用户（顾客）设计不同的操作界面和权限，确保每个角色都能专注于其职责范围内的操作，避免信息过载和误操作。
-   **培训与支持**：对于酒店内部员工，可以提供简单的操作培训和使用手册。对于顾客而言，在线预订等操作流程会设计得尽可能简单明了，符合大众在线购物或服务的习惯。
-   **系统稳定性与响应速度**：采用成熟的技术栈和合理的系统设计，保障系统的稳定运行和快速响应，避免因系统卡顿或频繁出错影响用户操作。

我们相信，通过人性化的界面设计、清晰的操作流程以及必要的引导，系统的各类用户都能够顺利掌握并有效使用，因此，本系统具备良好的操作可行性。

3.2 功能需求分析
功能需求是系统必须具备的核心能力，它直接关系到系统能否满足用户的业务需求。根据前期对商务酒店运营流程的调研和您提供的需求列表，我们将系统的主要功能模块需求梳理如下：

3.2.1 用户账户管理模块需求
这是系统的基础支撑模块，为所有系统交互提供身份识别和权限控制。
1.  **用户注册**：允许新顾客在线注册账户，提供用户名、密码、联系方式等基本信息。系统需对用户名唯一性进行校验，密码进行加密存储。
2.  **用户登录**：已注册用户（包括顾客、酒店员工）通过用户名和密码登录系统。登录成功后，系统应能识别用户角色并授予相应权限。支持登录失败次数限制、验证码等安全机制（可作为扩展）。
3.  **密码管理**：允许用户修改自己的登录密码，可能需要验证旧密码。管理员应具备重置用户密码的功能。
4.  **账户信息查看与修改**：用户可以查看和修改自己的个人基本信息（如联系方式、邮箱等，但不包括用户名和角色）。
5.  **员工账户管理（管理员权限）**：
    -   增加、删除、修改酒店员工账户（如前台、清洁人员、其他管理员）。
    -   为员工账户分配和调整角色及权限。
    -   管理员工账户的状态（如启用、禁用）。

3.2.2 用户（顾客）信息管理模块需求
主要针对酒店顾客的详细信息管理，服务于会员体系和精准营销。
1.  **顾客基本信息记录**：除了账户信息外，还需记录顾客的详细信息，如性别、生日、证件类型、证件号码、常用联系人信息（可选）等。
2.  **会员等级管理**：
    -   定义不同的会员等级（如普通会员、银卡、金卡等）及其对应的权益（如折扣率、积分加速等）。
    -   根据顾客的消费金额或入住次数自动或手动升级会员等级。
    -   展示会员当前的等级和权益。
3.  **会员积分管理**：
    -   根据消费金额按一定规则累积积分。
    -   支持积分兑换礼品或服务（可选）。
    -   记录积分的获取和使用明细。
4.  **消费记录查询**：顾客可以查询自己在酒店的历史消费记录。
5.  **顾客信息查询与维护（管理员/前台权限）**：酒店员工可以根据条件查询顾客信息，并进行必要的维护。

3.2.3 房间预订模块需求
这是系统的核心业务模块之一，为顾客提供在线预订服务。
1.  **房型信息展示**：向顾客清晰展示酒店提供的所有房型信息，包括房型名称、图片、面积、床型、设施、价格（区分平日、周末、节假日）、可入住人数等。
2.  **房间可用性查询**：顾客可以根据选择的入住日期、离店日期、房型（可选）、入住人数等条件，查询可用房间。系统需实时显示房间的可用状态。
3.  **在线预订**：顾客选择满意的房型和房间（如果系统支持选具体房间号）后，填写预订人信息、入住人信息（可能多人）、预计到店时间、特殊需求等，提交预订订单。
4.  **预订订单生成与确认**：系统自动生成唯一的预订订单号，记录预订详情。根据酒店策略，预订可能需要支付担保或直接进入待确认状态，等待酒店前台确认。
5.  **订单管理（顾客）**：顾客可以查看自己的预订订单列表、订单详情、订单状态（如待确认、已确认、已取消、已入住、已完成）。在符合酒店取消政策的前提下，顾客可以取消预订。
6.  **订单管理（酒店员工）**：前台或管理员可以查看所有预订订单，确认新订单，修改订单信息（在一定权限和规则下），处理顾客的取消请求等。

3.2.4 入住管理模块需求
处理顾客到店后的入住登记及在住期间的管理。
1.  **入住登记（Check-in）**：
    -   基于预订入住：前台根据预订订单号或顾客姓名快速调取预订信息，核对入住人证件，办理入住手续，分配具体房间，记录押金。
    -   无预订直接入住（散客入住）：前台为直接到店的顾客选择可用房间，录入顾客信息，办理入住。
    -   系统需记录实际入住时间、入住人数、随行人员信息（可选）。
2.  **房态管理**：房间状态（如可用、已预订、已入住、清洁中、维修中等）需实时更新并直观显示给前台人员。办理入住后，对应房间状态应变更为"已入住"。
3.  **续住与换房**：支持在住客人办理续住（需检查房间后续可用性）和换房操作，并更新相关记录和费用。
4.  **杂费管理**：记录住客在店期间可能产生的额外消费（如餐饮、洗衣等），并计入账单（可选，取决于系统复杂度）。
5.  **退房结算（Check-out）**：
    -   计算住客应付总费用（房费+杂费-已付/押金）。
    -   处理收款，打印账单（可选）。
    -   更新房间状态为"待清洁"或"可用"（根据清洁流程）。
    -   记录实际退房时间。
6.  **入住历史查询**：酒店员工可以查询历史入住记录。

3.2.5 人员来访登记模块需求
保障酒店安全，规范访客管理。
1.  **访客信息登记**：对来访酒店住客的外部人员，需登记其基本信息（姓名、联系方式、证件信息）、被访客人姓名及房号、来访事由、预计来访时间。
2.  **进入与离开时间记录**：记录访客的实际进入时间和离开时间。
3.  **访客查询**：安保或前台人员可以根据条件查询当前的在访人员或历史来访记录。

3.2.6 酒店信息展示模块需求
向潜在顾客和住客展示酒店的整体情况，提升吸引力。
1.  **酒店概况展示**：包括酒店介绍、地理位置（可集成地图）、联系方式、交通指南等。
2.  **设施与服务展示**：展示酒店提供的各项设施（如餐厅、会议室、健身房、停车场等）和服务（如洗衣、送餐、叫醒等）的图文介绍。
3.  **图片与视频展示**：通过高质量的图片和视频展示酒店环境、客房内部、公共区域等。
4.  **顾客评价展示（可选）**：展示来自真实住客的评价，增加可信度。
5.  **促销与活动信息发布**：发布酒店近期的优惠活动、套餐信息等。

3.2.7 统计分析模块需求
为酒店管理者提供数据支持，辅助经营决策。
1.  **入住率统计**：按日、周、月、季度、年统计酒店的整体入住率、不同房型的入住率。
2.  **营收统计**：统计房费收入、其他消费收入（如餐饮、服务费），分析营收构成和趋势。
3.  **客源分析**：分析顾客来源地、会员占比、预订渠道（如官网、电话、OTA）等（部分数据可能需与其他系统集成或手动录入）。
4.  **预订情况统计**：统计预订数量、取消率、提前预订天数等。
5.  **报表生成与导出**：能够生成标准格式的统计报表（如日报、月报），并支持导出为Excel或PDF等格式。
6.  **数据可视化**：采用柱状图、折线图、饼图等多种图表形式，直观展示各项统计分析结果。

3.3 非功能需求分析
非功能需求描述了系统应具备的质量属性，虽然不直接对应具体操作，但对用户体验和系统成败至关重要。

3.3.1 系统性能需求
-   **响应时间**：用户常用操作（如页面加载、查询、提交表单）的平均响应时间应在可接受范围内（例如，一般查询操作在3秒内，复杂报表生成可适当放宽）。
-   **并发用户数**：系统应能支持一定数量的用户同时在线操作，尤其是在预订高峰期或前台集中办理入住/退房时，不能出现明显性能下降或服务不可用。初期可设定一个合理的并发目标（如50-100个并发用户），并为未来扩展留有余地。
-   **数据处理能力**：系统能够高效处理日常的业务数据量，数据库查询和写入操作不应成为瓶颈。

3.3.2 系统安全性需求
-   **用户认证与授权**：严格的用户身份验证机制，确保只有授权用户才能访问其权限范围内的功能和数据。采用基于角色的访问控制（RBAC）。
-   **密码安全**：用户密码必须加密存储（如使用BCrypt等哈希算法加盐处理），传输过程中也应采取加密措施（如HTTPS）。
-   **数据传输安全**：对于敏感数据（如用户信息、支付信息虽然本系统可能不直接处理支付，但若有相关接口也需考虑），在网络传输过程中应使用HTTPS协议进行加密。
-   **防范常见Web攻击**：需要采取措施防范常见的Web安全漏洞，如SQL注入、跨站脚本攻击（XSS）、跨站请求伪造（CSRF）等。框架层面（如Spring Security）会提供部分防护，但编码时也需注意安全规范。
-   **数据备份与恢复**：应制定定期的数据备份策略，确保在发生意外情况（如硬件故障、数据损坏）时能够及时恢复数据。
-   **操作日志**：记录关键操作的日志（如用户登录、重要数据修改、删除等），便于审计和问题追溯。

3.3.3 系统可维护性需求
-   **代码规范与可读性**：遵循统一的编码规范，编写清晰、易懂的代码，添加必要的注释，方便后续维护和升级。
-   **模块化设计**：系统采用模块化设计，各模块之间低耦合、高内聚，修改一个模块不应过多影响其他模块。
-   **配置管理**：系统中的可配置项（如数据库连接信息、第三方服务密钥等）应通过配置文件进行管理，而不是硬编码在代码中。
-   **日志记录**：完善的日志系统，能够记录系统运行状态、错误信息等，方便问题排查。
-   **文档齐全**：提供必要的开发文档（如需求文档、设计文档、API文档）和用户手册。

3.3.4 系统易用性需求
-   **界面直观友好**：用户界面设计应简洁、美观、布局合理，符合用户操作习惯。重要功能和信息应易于查找。
-   **操作流程顺畅**：各项业务操作流程应设计得尽可能简单、高效，减少不必要的步骤和用户输入。
-   **提示与反馈明确**：对于用户的操作，系统应给予及时、明确的反馈（如成功提示、错误警告、加载状态等）。对于复杂操作，应提供必要的引导和帮助信息。
-   **一致性**：系统内各模块的界面风格、操作方式、术语等应保持一致性。
-   **响应式设计（可选但推荐）**：前端界面能适应不同尺寸的屏幕（如PC、平板、手机），提供良好的跨设备体验。

3.4 系统角色分析
为了更好地理解不同用户与系统的交互方式及其权限范围，我们定义以下主要系统角色：

3.4.1 游客（未登录用户）
游客是未经身份验证的匿名用户，他们可以访问系统的前台公共信息。
-   浏览酒店概况、设施服务、图片视频等宣传信息。
-   查看房型详情和大致价格区间。
-   查询特定日期和房型的房间可用性（可能不显示具体价格或无法直接预订，引导注册/登录）。
-   进行用户注册。

3.4.2 注册用户（顾客）
已注册并成功登录的酒店顾客，拥有更广泛的个性化服务权限。
-   拥有游客的所有权限。
-   在线预订房间，管理自己的预订订单（查看、修改在允许条件下、取消）。
-   查看和修改个人账户信息、密码。
-   查看自己的会员等级、积分、消费记录。
-   发表住后评价（可选）。

3.4.3 酒店管理员
酒店的高级管理人员或系统维护人员，拥有系统的最高管理权限。
-   管理酒店基础信息（如酒店介绍、联系方式、政策等）。
-   管理房型信息（增删改查）。
-   管理具体房间信息（增删改查，调整房间状态如维修）。
-   管理所有预订订单，进行确认、修改、取消等操作。
-   管理入住和退房记录。
-   管理员工账户（增删改查，分配角色，启用/禁用账户）。
-   管理会员等级规则，查看会员信息。
-   查看和管理访客登记记录。
-   查看各类统计报表，进行数据分析。
-   管理系统配置（可选）。
-   (可能还细分为超级管理员和普通管理员，权限有所区别)

3.4.4 前台接待人员 (一种特殊的酒店员工角色)
直接在前台操作，为顾客提供服务的核心员工。
-   查询房间可用性和房态。
-   处理顾客的预订（电话预订录入、网络预订确认）。
-   为顾客办理入住登记手续，分配房间，收取押金。
-   为顾客办理退房结算手续，处理收款。
-   处理续住、换房等在住客人的请求。
-   管理当前入住客人信息。
-   登记和管理访客信息。
-   查看部分业务报表（如当日预抵/预离列表、当前房态图）。

3.4.5 清洁人员 (一种特殊的酒店员工角色)
负责客房清洁和维护的员工。
-   查看分配给自己的清洁任务列表（哪些房间需要清洁）。
-   更新清洁任务的状态（如开始清洁、清洁完成）。
-   上报房间内物品损坏或需要维修的情况（可选）。

通过对这些角色的明确划分，系统可以实现精细化的权限管理，确保每个用户只能访问其职责和权限范围内的信息和功能，保障系统的安全有序运行。

3.5 系统用例分析
用例是描述用户（或外部系统）如何使用系统来完成特定目标的一种方式。通过用例分析，我们可以更清晰地理解用户与系统之间的交互场景。下面将分别针对注册用户（顾客）和酒店管理员（代表酒店员工）绘制简化的用例图。

3.5.1 注册用户（顾客）用例图
(此处可在论文中插入用例图图片，以下为文字描述关键用例)
主要参与者：注册用户（顾客）
主要用例：
-   用户注册
-   用户登录
-   浏览酒店信息
-   浏览房型信息
-   查询房间可用性
-   创建预订订单
-   查看我的订单
-   取消订单
-   修改个人信息
-   修改密码
-   查看会员信息
-   (发表评价)

3.5.2 酒店管理员用例图
(此处可在论文中插入用例图图片，以下为文字描述关键用例)
主要参与者：酒店管理员
主要用例：
-   用户登录 (管理员身份)
-   管理员工账户
-   管理顾客信息
-   管理会员等级
-   管理房型
-   管理房间
-   管理预订订单
-   管理入住记录
-   管理退房记录
-   管理访客登记
-   管理清洁任务 (分配、查看)
-   查看统计报表
-   管理酒店信息
-   (管理系统配置)

(注：前台接待人员和清洁人员的用例图可以作为管理员用例图的子集或单独绘制，具体取决于论文的详细程度和篇幅。)

通过以上详细的需求分析，我们为后续的系统设计与实现奠定了坚实的基础。每一个需求的明确，都像是为最终的系统大厦添砖加瓦，确保其功能完善、用户满意。当然，需求是一个动态演进的过程，在后续的设计和开发中，我们可能还会根据实际情况进行适当的调整和细化。

第四章 系统设计

在完成了详尽的需求分析之后，我们便迈入了系统设计的阶段。这个阶段，就如同建筑师依据蓝图细化每一处结构、每一根梁柱，目标是将抽象的需求转化为具体可行的技术实现方案。本章将重点阐述“基于B/S架构的商务酒店预订管理系统”的总体架构设计、核心功能模块的详细设计以及至关重要的数据库设计，为后续的编码实现铺平道路。

4.1 系统总体架构设计

一个清晰、合理的系统架构是软件项目成功的关键。它不仅影响着系统的性能、可扩展性和可维护性，也直接关系到开发效率和团队协作。

4.1.1 系统架构图 (B/S三层架构)
本项目采用业界广泛应用的B/S（浏览器/服务器）架构，并在此基础上细化为经典的三层架构模型：表现层（Presentation Layer）、业务逻辑层（Business Logic Layer）和数据访问层（Data Access Layer）。

(此处可在论文中插入系统架构图图片，例如一个展示用户浏览器、Web服务器（Nginx/Tomcat）、应用服务器（Spring Boot应用）、数据库（MySQL）之间关系的示意图，并标注出三层结构。)

**文字描述如下：**

1.  **表现层 (Presentation Layer)**：
    -   **客户端 (Browser)**：用户通过标准的Web浏览器（如Chrome, Firefox, Edge等）与系统进行交互。前端界面采用Vue.js框架构建，负责向用户展示信息、接收用户输入，并通过HTTP(S)协议与后端应用服务器进行数据通信。Element Plus组件库用于构建美观易用的UI元素，Vue Router负责前端路由管理，Pinia进行状态管理。
    -   **Web服务器 (可选，如Nginx)**：在生产环境中，通常会在应用服务器前部署一个Web服务器（如Nginx），用于处理静态资源（如HTML, CSS, JavaScript文件, 图片）、进行反向代理、负载均衡以及SSL卸载等，提升系统性能和安全性。对于开发阶段或小型部署，Spring Boot内嵌的Web服务器（如Tomcat）也可直接面向用户。

2.  **业务逻辑层 (Business Logic Layer)**：
    -   **应用服务器 (Spring Boot Application)**：这是系统的核心，负责处理所有的业务逻辑。
        -   **Controller层**：接收来自前端的HTTP请求，对请求参数进行初步校验，并将请求分发给相应的Service层进行处理。它充当着表现层与业务逻辑层之间的桥梁，通常采用RESTful API风格设计接口。
        -   **Service层**：封装核心的业务规则和处理流程。例如，用户注册服务、订单创建服务、房间状态更新服务等。Service层会调用Data Access Layer进行数据操作，并可能协调多个数据操作以完成一个完整的业务事务。

3.  **数据访问层 (Data Access Layer)**：
    -   **Repository层 (Spring Data JPA)**：负责与数据库进行交互，实现数据的持久化存储和检索。通过定义继承自Spring Data JPA接口（如`JpaRepository`）的Repository接口，我们可以用非常简洁的方式实现对数据库的CRUD（创建、读取、更新、删除）操作，而无需编写大量的JDBC样板代码。
    -   **实体类 (Entities)**：定义了与数据库表结构相映射的Java对象（POJO），使用JPA注解（如`@Entity`, `@Table`, `@Id`, `@Column`, `@ManyToOne`, `@OneToMany`等）来描述对象与表的映射关系。
    -   **数据库 (MySQL)**：作为最终的数据存储介质，负责持久化存储系统的所有业务数据。

**这种分层架构的优势显而易见：**
-   **职责清晰**：每一层都有明确的职责，便于开发和维护。
-   **松耦合**：层与层之间通过定义好的接口进行交互，降低了模块间的依赖性。例如，更换数据库或调整业务逻辑，可以尽量减少对其他层的影响。
-   **可复用性高**：Service层封装的业务逻辑可以被不同的Controller调用，Repository层的数据访问逻辑也可以被多个Service复用。
-   **易于测试**：可以针对每一层进行独立的单元测试和集成测试。
-   **便于团队协作**：不同经验的开发者可以专注于不同层次的开发工作。

4.1.2 技术选型
在需求分析阶段我们已对主要技术进行了可行性评估，本节再次明确并概括系统的技术选型：

-   **后端框架**：Spring Boot 2.7.x (或更高稳定版本)。利用其快速开发、自动化配置、内嵌服务器、以及与Spring生态（Spring Security, Spring Data JPA）的无缝集成能力。
-   **安全框架**：Spring Security。用于实现用户认证、授权以及常见的Web安全防护。结合JWT (JSON Web Token) 实现无状态认证，适应前后端分离架构。
-   **数据持久化**：Spring Data JPA + Hibernate。通过面向对象的方式操作数据库，简化数据访问层的开发。Hibernate作为JPA的实现，提供强大的ORM功能。
-   **数据库**：MySQL 8.0+。开源、稳定、性能良好，广泛应用于Web应用。
-   **前端框架**：Vue.js 3.x。渐进式JavaScript框架，轻量、高效、易上手，拥有活跃的生态。
-   **前端UI组件库**：Element Plus。一套为Vue 3打造的企业级UI组件库，提供丰富、美观、易用的组件。
-   **前端构建工具**：Vite。新一代前端构建工具，提供极速的冷启动和热模块更新，提升开发体验。
-   **前端状态管理**：Pinia。Vue 3推荐的状态管理库，轻量、易用、类型安全。
-   **HTTP客户端 (前端)**：Axios。一个基于Promise的HTTP客户端，用于浏览器和Node.js，方便进行API请求。
-   **前端路由**：Vue Router。Vue.js官方的路由管理器。
-   **API文档工具**：Swagger/OpenAPI (如通过SpringDoc等库集成)。自动生成并展示RESTful API文档，方便前后端协作和接口测试。
-   **项目构建工具 (后端)**：Maven。管理项目依赖、构建、打包等。
-   **版本控制工具**：Git。进行代码的版本管理和团队协作。

这一套技术栈组合，既考虑了技术的成熟度和稳定性，也兼顾了开发效率和现代Web应用的特性需求，能够很好地支撑本酒店管理系统的设计与实现。

4.2 功能模块设计
根据第三章的需求分析，我们将系统划分为若干核心功能模块，并对每个模块进行详细设计。功能模块主要分为前台功能模块（面向顾客和游客）和后台管理功能模块（面向酒店员工）。

4.2.1 前台功能模块设计
前台系统是酒店直接面向顾客的窗口，其设计的好坏直接影响用户体验和酒店形象。

4.2.1.1 用户注册登录模块
-   **用户注册**：
    -   界面：提供清晰的注册表单，包含用户名、密码（及确认密码）、手机号、邮箱（可选）、姓名等字段，并有明确的输入提示和校验规则。
    -   流程：用户填写信息 -> 前端进行基本格式校验 -> 点击注册 -> 后端接收数据 -> 后端校验用户名/手机号唯一性 -> 密码加密存储 -> 创建用户记录（默认顾客角色） -> 返回注册成功/失败信息。
-   **用户登录**：
    -   界面：简洁的登录表单，输入用户名和密码。可考虑“记住我”选项和“忘记密码”链接（后者为扩展功能）。
    -   流程：用户输入凭证 -> 前端发送登录请求 -> 后端验证用户名密码（通过Spring Security） -> 验证成功则生成JWT返回给前端 -> 前端存储JWT并根据用户角色跳转到相应主页 -> 验证失败则提示错误信息。
-   **个人信息修改**：
    -   界面：允许登录用户查看并修改部分个人信息（如昵称、联系方式、生日等，用户名和角色通常不允许用户自行修改）。
    -   流程：用户在个人中心修改信息 -> 提交 -> 后端验证并更新数据库。
-   **密码修改**：
    -   界面：要求输入旧密码、新密码、确认新密码。
    -   流程：用户提交 -> 后端验证旧密码是否正确 -> 新密码与确认密码一致性校验 -> 更新加密后的新密码。

4.2.1.2 酒店及房间信息展示模块
-   **酒店首页/概况页**：
    -   内容：展示酒店的整体介绍、特色、地理位置（可嵌入地图）、联系方式、宣传图片/视频。
    -   设计：注重品牌形象和信息传递的直观性。
-   **房型列表页**：
    -   内容：以卡片或列表形式展示所有可预订的房型，每个房型包含缩略图、名称、简要描述、参考价格、可入住人数等关键信息。
    -   功能：提供筛选（如按价格、可入住人数）和排序功能。点击某个房型可进入房型详情页。
-   **房型详情页**：
    -   内容：详细展示特定房型的多张高清图片、详细描述（面积、床型、设施、景观等）、各项价格（平日、周末、节假日）、入住政策、取消政策等。
    -   功能：通常在此页面提供日期选择器，供用户查询该房型在特定日期范围内的可用性和具体价格，并引导至预订流程。
-   **房间可用性查询**：
    -   界面：通常包含入住日期、离店日期选择器，以及可选的入住人数、房型偏好等筛选条件。
    -   流程：用户选择条件 -> 前端发送查询请求 -> 后端根据条件实时查询数据库中房间的预订和入住情况，结合房态信息 -> 返回可用房型列表及其在选定日期内的具体价格。

4.2.1.3 房间预订模块
-   **预订信息填写页**：
    -   内容：在用户选择了日期和房型（及数量）后，进入此页面填写预订人联系信息（姓名、手机、邮箱）、实际入住人信息（可能与预订人不同，可能需要填写多位入住人的基本信息）、预计到店时间、特殊需求（如无烟房、高楼层等备注）。页面会清晰显示所选房型、日期、价格明细和总价。
    -   流程：用户填写完毕 -> 前端进行表单校验 -> 点击“提交订单”。
-   **订单确认与支付（简化处理）**：
    -   对于毕业设计，支付环节通常简化处理。提交订单后，后端生成预订记录，状态可能为“待确认”或“已确认”（取决于酒店是否需要人工审核或是否有库存即时确认机制）。
    -   界面：向用户展示预订成功的提示，包含订单号、预订详情摘要。
-   **我的订单页**：
    -   内容：登录用户可以查看自己的历史预订订单列表，每条订单显示关键信息（订单号、酒店名、房型、入住日期、订单状态、总价）。
    -   功能：点击订单可查看详情。对于符合取消政策的“已确认”或“待确认”订单，提供“取消订单”按钮。

4.2.1.4 个人中心模块 (订单管理、个人信息修改等)
这是登录用户的专属区域，整合了与用户个人相关的各项功能。
-   **导航**：清晰的导航菜单，如“我的订单”、“个人资料”、“修改密码”、“我的会员”（如果实现了会员功能）、“我的评价”（如果实现了评价功能）。
-   **我的订单**：如4.2.1.3中所述。
-   **个人资料**：如4.2.1.1中所述的个人信息修改功能。
-   **修改密码**：如4.2.1.1中所述。
-   **会员信息（若有）**：展示用户的会员等级、当前积分、积分历史、会员权益等。

4.2.2 后台管理功能模块设计
后台管理系统是酒店员工进行日常运营管理的核心平台，需要功能全面、操作高效、权限分明。

4.2.2.1 用户管理模块 (顾客账户与员工账户管理)
-   **顾客账户管理（管理员权限）**：
    -   列表展示：分页展示所有注册顾客的账户信息（用户名、姓名、联系方式、会员等级、状态等）。
    -   查询与筛选：支持按用户名、手机号、会员等级等条件进行查询和筛选。
    -   查看详情：查看顾客的详细注册信息、消费记录、预订历史等。
    -   状态管理：可以禁用或启用顾客账户。
    -   (通常不直接修改顾客密码，但可提供重置密码功能，发送重置链接到邮箱/手机)
-   **员工账户管理（管理员权限）**：
    -   列表展示：分页展示所有酒店员工的账户信息（用户名、姓名、所属部门/角色、状态等）。
    -   增/删/改/查：管理员可以添加新的员工账户，编辑现有员工信息（如调整角色、联系方式），删除离职员工账户。
    -   角色分配：为员工账户精确分配系统角色（如前台、清洁主管、普通管理员等），对应不同的操作权限。
    -   密码重置：管理员可以为员工重置登录密码。

4.2.2.2 酒店及房间管理模块
-   **酒店基本信息管理（管理员权限）**：
    -   界面：提供表单编辑酒店的名称、地址、联系电话、简介、政策（如入住/退房时间、取消政策）、LOGO、宣传图等。
    -   流程：管理员修改并保存 -> 更新数据库中的酒店信息。
-   **房型管理（管理员权限）**：
    -   列表展示：显示所有房型及其关键信息（名称、基础价格、容量等）。
    -   增/删/改/查：管理员可以添加新的房型，定义其名称、描述、价格（平日/周末/节假日）、可入住人数、床型、面积、设施列表、上传房型图片等。可以修改或删除现有房型。
-   **房间管理（管理员/前台权限，权限范围可能不同）**：
    -   列表展示：显示酒店所有具体房间的信息（房间号、所属房型、楼层、当前状态等）。通常会有一个更直观的“房态图”界面。
    -   增/删/改/查：管理员可以添加新房间，关联到已定义的房型，设置房间号、楼层等。可以修改房间信息。删除房间需谨慎操作（如房间无未来预订和当前入住）。
    -   状态维护：管理员或前台可以手动修改房间状态（如设置为“维修中”、“清洁完成”等，部分状态会由业务流程自动更新）。

4.2.2.3 订单管理模块 (后台)
-   **预订订单列表（管理员/前台权限）**：
    -   内容：分页显示所有顾客的预订订单，包含订单号、预订人、入住人、房型、入住/离店日期、订单状态、总金额等。
    -   查询与筛选：支持按订单号、预订人姓名/手机、入住日期范围、订单状态等多种条件进行查询和筛选。
-   **订单详情查看**：点击订单可查看完整的预订信息和顾客备注。
-   **订单操作**：
    -   确认订单：对于“待确认”的订单，前台或管理员进行审核（如检查库存、支付情况）后，可以将其状态更新为“已确认”。
    -   修改订单（有限）：在特定条件下（如顾客申请、未锁定库存前），可能允许修改订单的某些信息（如入住人、联系方式，甚至在有房情况下调整日期或房型，但这会涉及价格重新计算，流程较复杂）。
    -   取消订单：根据酒店取消政策和订单状态，处理取消请求，更新订单状态为“已取消”，并可能触发退款流程（退款本身为扩展功能）。
    -   备注添加：可以为订单添加内部备注，方便员工间沟通。

4.2.2.4 入住与退房管理模块
-   **入住办理界面（前台权限）**：
    -   通过预订号/姓名/手机号快速检索预订信息，或直接为无预订散客开单。
    -   选择/分配房间（系统可推荐可用房间）。
    -   登记所有入住人的有效证件信息。
    -   确认入住日期、预计离店日期、房价、收取押金。
    -   打印入住单（可选）。
    -   更新房间状态为“已入住”，更新订单状态（若关联预订）。
-   **在住客人管理（前台权限）**：
    -   列表展示当前所有已入住的客人信息（房号、姓名、入住日期、预计离店日期等）。
    -   处理续住请求：检查房间后续可用性，更新离店日期和费用。
    -   处理换房请求：选择可用房间，更新房间记录和费用（可能涉及差价）。
    -   登记额外消费（如迷你吧、送餐）。
-   **退房办理界面（前台权限）**：
    -   根据房号或姓名检索入住记录。
    -   核对消费明细（房费、杂费）。
    -   计算应付/应退金额（扣除押金）。
    -   处理收款/退款。
    -   打印结账单（可选）。
    -   更新房间状态为“待清洁”，更新订单/入住记录状态为“已完成”/“已退房”。

4.2.2.5 访客登记管理模块
-   **访客登记界面（前台/安保权限）**：
    -   表单包含访客姓名、联系方式、证件号码（可选）、被访客人姓名、被访房间号、来访事由、预计来访时长。
    -   记录访客进入时间。
-   **访客离开登记**：找到对应访客记录，登记其离开时间。
-   **访客记录查询**：
    -   可查询当前在访的客人列表。
    -   可按日期、访客姓名、被访人等条件查询历史访客记录。

4.2.2.6 统计报表模块
-   **数据看板/概览页（管理员权限）**：
    -   以图表（如折线图、饼图、仪表盘）和关键数字的形式，直观展示酒店当日/当月核心运营指标，如总入住率、总营收、平均房价、可用房间数、今日预抵/预离数等。
-   **具体报表**：
    -   入住率报表：按日/周/月等多维度展示入住率，可按房型细分。
    -   营收报表：按日/周/月等多维度展示总营收、房费收入、其他收入等，可按来源（如不同预订渠道，若有此数据）细分。
    -   客源分析报表：统计不同地区客源占比、新老顾客占比、会员顾客占比等。
    -   预订分析报表：统计预订量、取消率、平均提前预订天数等。
-   **报表功能**：
    -   支持按日期范围、房型等条件筛选报表数据。
    -   支持报表数据的导出（如Excel, CSV）。
    -   部分关键数据采用ECharts等图表库进行可视化展示。

4.3 数据库设计
数据库是整个系统的基石，负责存储和管理所有业务数据。本节将描述数据库的概念结构设计和逻辑结构设计。

4.3.1 数据库概念结构设计 (E-R图)
概念结构设计阶段，我们主要从用户的角度看待数据，识别系统中的核心实体及其之间的联系，通常使用E-R（实体-联系）图来表示。

**核心实体包括：**
-   用户 (User)
-   角色 (Role) (如果User实体中的role字段不足以描述复杂权限，则需要独立Role实体及Permission实体)
-   酒店信息 (HotelInfo)
-   房型 (RoomType)
-   房间 (Room)
-   预订 (Reservation/Booking)
-   入住记录 (CheckInRecord)
-   访客记录 (VisitorRecord)
-   清洁记录 (CleaningRecord)
-   会员等级 (MemberLevel) (用于定义等级规则，User实体中存储用户的当前等级)

**它们之间的主要联系（简要描述，具体关系在逻辑设计中体现）：**
-   一个用户可以有多个预订，一个预订属于一个用户。
-   一个房间可以被多次预订（不同时间段），一个预订通常对应一个或多个房间（如果一个订单预订多间同类型房）。
-   一个房间属于一个特定的房型。一个房型下可以有多个房间。
-   一个入住记录可能关联一个预订，也可能不关联（散客）；一个入住记录对应一个房间和一个或多个住客。
-   一个用户可以有多个访客记录（作为被访者）；一个访客记录记录一个访客的来访。
-   一个房间可以有多条清洁记录；一个清洁记录对应一个房间，可能关联一个清洁人员（用户）。
-   用户可以拥有一个会员等级。

(此处可在论文中插入根据上述实体和关系绘制的整体E-R图或核心部分的E-R图。)

4.3.2 数据库逻辑结构设计 (表结构)
在逻辑结构设计阶段，我们将E-R图转换为关系数据库管理系统（本项目为MySQL）所支持的表结构。以下是主要数据表的字段定义（基于之前分析的实体类，并参考了您的`毕业论文-商务酒店预订管理系统.txt`文件中的表结构，进行整合和确认）：

            4.3.2.1 用户表 (users)
            用户表用于存储所有系统用户的信息，包括顾客、前台、清洁人员和管理员。
            表4-1 用户表 (users)
            | 字段名称        | 数据类型          | 约束/索引     | 说明             |
            |-----------------|-------------------|---------------|------------------|
            | id              | BIGINT            | 主键, 自增    | 用户唯一标识符     |
            | username        | VARCHAR(255)      | 非空, 唯一    | 用户登录名       |
            | password        | VARCHAR(255)      | 非空          | 加密后的登录密码   |
            | name            | VARCHAR(255)      | 非空          | 用户真实姓名     |
            | phone           | VARCHAR(255)      | 唯一(可选约束) | 联系电话         |
            | email           | VARCHAR(255)      | 非空, 唯一(可选约束) | 电子邮箱         |
            | gender          | VARCHAR(10)       |               | 性别 (如: MALE, FEMALE, UNKNOWN) |
            | birthday        | DATE              |               | 出生日期         |
            | id_type         | VARCHAR(50)       |               | 证件类型 (枚举或字符串)  |
            | id_number       | VARCHAR(255)      |               | 证件号码         |
            | role            | VARCHAR(50)       | 非空          | 用户角色 (枚举: CUSTOMER, RECEPTIONIST, CLEANER, ADMIN, SUPER_ADMIN)  |
            | status          | VARCHAR(20)       | 非空, 默认ACTIVE | 账户状态 (如: ACTIVE, DISABLED, PENDING_APPROVAL) |
            | member_level_id | BIGINT            | 外键(member_levels) | 当前会员等级ID (User实体中可能是枚举，但表结构用外键更规范) |
            | points          | INT               | 非空, 默认0   | 会员积分         |
            | total_spent     | DECIMAL(12,2)     | 非空, 默认0.00 | 累计消费金额     |
            | invitation_code | VARCHAR(50)       | 唯一(可选)    | 邀请码（若有此功能）|
            | create_time     | DATETIME          | DEFAULT CURRENT_TIMESTAMP | 记录创建时间     |
            | update_time     | DATETIME          | DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 记录更新时间     |

            4.3.2.2 角色表 (roles) - (如果User表中的role字段是简单枚举，且权限与角色强绑定，可能不需要此表和权限表。若需要动态权限配置，则需要)
            角色表定义了系统中的不同用户角色。
            表4-2 角色表 (roles)
            | 字段名称    | 数据类型       | 约束/索引  | 说明         |
            |-------------|----------------|------------|--------------|
            | id          | BIGINT         | 主键, 自增 | 角色ID       |
            | role_name   | VARCHAR(50)    | 非空, 唯一 | 角色名称 (如: ROLE_CUSTOMER, ROLE_ADMIN) |
            | description | VARCHAR(255)   |            | 角色描述     |
            | create_time | DATETIME       |            | 创建时间     |
            | update_time | DATETIME       |            | 更新时间     |

            4.3.2.3 权限表 (permissions) - (用于实现更细粒度的权限控制)
            权限表定义了系统中的具体操作权限。
            表4-3 权限表 (permissions)
            | 字段名称        | 数据类型       | 约束/索引  | 说明         |
            |-----------------|----------------|------------|--------------|
            | id              | BIGINT         | 主键, 自增 | 权限ID       |
            | permission_name | VARCHAR(100)   | 非空, 唯一 | 权限名称 (如: 查看订单, 编辑房间) |
            | permission_code | VARCHAR(100)   | 非空, 唯一 | 权限代码 (如: order:read, room:edit) |
            | description     | VARCHAR(255)   |            | 权限描述     |
            | create_time     | DATETIME       |            | 创建时间     |
            | update_time     | DATETIME       |            | 更新时间     |
            
            4.3.2.4 角色权限关联表 (role_permissions) - (多对多关系)
            表4-4 角色权限关联表 (role_permissions)
            | 字段名称      | 数据类型       | 约束/索引                      | 说明         |
            |---------------|----------------|--------------------------------|--------------|
            | role_id       | BIGINT         | 主键部分, 外键(roles)          | 角色ID       |
            | permission_id | BIGINT         | 主键部分, 外键(permissions)    | 权限ID       |

            4.3.2.5 酒店信息表 (hotel_info)
            存储酒店的基本信息（通常只有一条记录）。
            表4-5 酒店信息表 (hotel_info)
            | 字段名称      | 数据类型        | 约束/索引  | 说明           |
            |---------------|-----------------|------------|----------------|
            | id            | BIGINT          | 主键, 自增 | ID             |
            | name          | VARCHAR(255)    | 非空       | 酒店名称       |
            | address       | VARCHAR(500)    |            | 酒店地址       |
            | phone         | VARCHAR(50)     |            | 联系电话       |
            | email         | VARCHAR(255)    |            | 电子邮箱       |
            | description   | TEXT            |            | 酒店描述       |
            | check_in_time | VARCHAR(20)     |            | 标准入住时间 (如: 14:00) |
            | check_out_time| VARCHAR(20)     |            | 标准退房时间 (如: 12:00) |
            | logo_url      | VARCHAR(500)    |            | 酒店Logo图片URL |
            | images        | TEXT            |            | 酒店宣传图片URL列表 (JSON或逗号分隔) |
            | policies      | TEXT            |            | 酒店主要政策 (如取消政策、入住须知) |
            | create_time   | DATETIME        |            | 创建时间       |
            | update_time   | DATETIME        |            | 更新时间       |

            4.3.2.6 房间类型表 (room_types)
            存储酒店提供的不同房间类型的信息。
            表4-6 房间类型表 (room_types)
            | 字段名称          | 数据类型        | 约束/索引  | 说明                 |
            |-------------------|-----------------|------------|----------------------|
            | id                | BIGINT          | 主键, 自增 | 房型ID               |
            | name              | VARCHAR(255)    | 非空, 唯一 | 房型名称 (如豪华大床房)|
            | description       | TEXT            |            | 房型详细描述         |
            | base_price        | DECIMAL(10,2)   | 非空       | 基础价格/平日价格     |
            | weekend_price     | DECIMAL(10,2)   |            | 周末价格 (可选)      |
            | holiday_price     | DECIMAL(10,2)   |            | 节假日价格 (可选)    |
            | capacity          | INT             | 非空       | 标准入住人数         |
            | max_capacity      | INT             |            | 最大入住人数(含加床) |
            | extra_bed_price   | DECIMAL(10,2)   | 默认 0.00  | 加床价格             |
            | bed_type          | VARCHAR(100)    |            | 床型 (如: 1.8米大床, 1.2米双床) |
            | area              | VARCHAR(50)     |            | 房间面积描述 (如: 30-35平方米) |
            | amenities         | TEXT            |            | 房间设施 (JSON或逗号分隔, 如: WIFI,空调,电视) |
            | images            | TEXT            |            | 房型图片URL列表 (JSON或逗号分隔) |
            | sort_order        | INT             | 默认 0     | 显示排序             |
            | status            | VARCHAR(20)     | 非空, 默认AVAILABLE | 房型状态 (如: AVAILABLE, MAINTENANCE) |
            | create_time       | DATETIME        |            | 创建时间             |
            | update_time       | DATETIME        |            | 更新时间             |

            4.3.2.7 房间信息表 (rooms)
            存储酒店内每个具体房间的信息。
            表4-7 房间信息表 (rooms)
            | 字段名称        | 数据类型        | 约束/索引        | 说明                 |
            |-----------------|-----------------|------------------|----------------------|
            | id              | BIGINT          | 主键, 自增       | 房间ID               |
            | room_number     | VARCHAR(50)     | 非空, 唯一       | 房间号 (如: 8101, A302) |
            | room_type_id    | BIGINT          | 非空, 外键(room_types) | 关联的房型ID         |
            | floor           | VARCHAR(50)     |                  | 所在楼层             |
            | status          | VARCHAR(50)     | 非空, 默认AVAILABLE | 房间状态 (枚举: AVAILABLE, OCCUPIED, RESERVED, MAINTENANCE, CLEANING, NEEDS_CLEANING, DISABLED) |
            | notes           | TEXT            |                  | 房间备注 (如: 近电梯, 景观好) |
            | create_time     | DATETIME        |                  | 创建时间             |
            | update_time     | DATETIME        |                  | 更新时间             |

            4.3.2.8 预订订单表 (reservations)
            存储用户的房间预订信息。
            表4-8 预订订单表 (reservations)
            | 字段名称            | 数据类型        | 约束/索引      | 说明                   |
            |---------------------|-----------------|----------------|------------------------|
            | id                  | BIGINT          | 主键, 自增     | 预订ID                 |
            | order_number        | VARCHAR(100)    | 非空, 唯一     | 订单号 (系统生成)      |
            | user_id             | BIGINT          | 外键(users), 可空(若允许非会员预订) | 预订用户ID             |
            | room_type_id        | BIGINT          | 非空, 外键(room_types) | 预订的房型ID          |
            | room_id             | BIGINT          | 外键(rooms), 可空(预订时可能不分配具体房间) | 实际分配的房间ID     |
            | guest_name          | VARCHAR(255)    | 非空           | 主要联系人姓名         |
            | guest_phone         | VARCHAR(50)     | 非空           | 主要联系人电话         |
            | number_of_rooms     | INT             | 非空, 默认1    | 预订房间数量           |
            | number_of_adults    | INT             |                | 成人数                 |
            | number_of_children  | INT             |                | 儿童数                 |
            | check_in_date       | DATE            | 非空           | 预计入住日期           |
            | check_out_date      | DATE            | 非空           | 预计退房日期           |
            | estimated_arrival_time | VARCHAR(50)  |                | 预计到店时间           |
            | total_price         | DECIMAL(12,2)   | 非空           | 订单总金额             |
            | deposit_amount      | DECIMAL(12,2)   | 默认 0.00      | 已付押金/预付款        |
            | payment_status      | VARCHAR(50)     | 非空, 默认UNPAID | 支付状态 (如: UNPAID, PAID, PARTIALLY_PAID, REFUNDED) |
            | reservation_status  | VARCHAR(50)     | 非空, 默认PENDING | 预订状态 (如: PENDING, CONFIRMED, CANCELLED, CHECKED_IN, COMPLETED) |
            | special_requests    | TEXT            |                | 特殊要求/备注          |
            | create_time         | DATETIME        |                | 创建时间               |
            | update_time         | DATETIME        |                | 更新时间               |
            | cancelled_time      | DATETIME        |                | 取消时间               |
            | cancelled_reason    | TEXT            |                | 取消原因               |

            4.3.2.9 入住记录表 (check_in_records)
            记录客人的实际入住信息。
            表4-9 入住记录表 (check_in_records)
            | 字段名称            | 数据类型        | 约束/索引      | 说明                  |
            |---------------------|-----------------|----------------|-----------------------|
            | id                  | BIGINT          | 主键, 自增     | 入住记录ID            |
            | reservation_id      | BIGINT          | 外键(reservations), 可空 | 关联的预订ID         |
            | room_id             | BIGINT          | 非空, 外键(rooms) | 入住房间ID            |
            | primary_guest_name  | VARCHAR(255)    | 非空           | 主要登记人姓名        |
            | primary_guest_id_type | VARCHAR(50)   |                | 主要登记人证件类型    |
            | primary_guest_id_number| VARCHAR(255)|                | 主要登记人证件号码    |
            | actual_check_in_time| DATETIME        | 非空           | 实际入住时间          |
            | actual_check_out_time| DATETIME       |                | 实际退房时间          |
            | number_of_nights    | INT             |                | 实际入住晚数          |
            | room_rate_actual    | DECIMAL(10,2)   |                | 实际入住房价(每晚)    |
            | total_room_charge   | DECIMAL(12,2)   |                | 房间总费用            |
            | total_extra_charge  | DECIMAL(12,2)   |                | 额外消费总费用        |
            | total_amount_due    | DECIMAL(12,2)   |                | 应付总金额            |
            | amount_paid         | DECIMAL(12,2)   |                | 已付金额              |
            | deposit_received    | DECIMAL(12,2)   |                | 已收押金              |
            | check_in_by_staff_id| BIGINT          | 外键(users)    | 办理入住员工ID        |
            | check_out_by_staff_id| BIGINT         | 外键(users)    | 办理退房员工ID        |
            | status              | VARCHAR(50)     | 非空           | 记录状态 (如: CHECKED_IN, CHECKED_OUT, FOLIO_OPEN) |
            | notes               | TEXT            |                | 备注                  |
            | create_time         | DATETIME        |                | 创建时间              |
            | update_time         | DATETIME        |                | 更新时间              |

            4.3.2.10 入住客人关联表 (check_in_guests) - (若一个入住记录对应多位实际住客)
            表4-10 入住客人关联表 (check_in_guests)
            | 字段名称          | 数据类型        | 约束/索引                  | 说明             |
            |-------------------|-----------------|----------------------------|------------------|
            | id                | BIGINT          | 主键, 自增                 | ID               |
            | check_in_record_id| BIGINT          | 非空, 外键(check_in_records)| 关联的入住记录ID |
            | guest_name        | VARCHAR(255)    | 非空                       | 住客姓名         |
            | guest_id_type     | VARCHAR(50)     |                            | 住客证件类型     |
            | guest_id_number   | VARCHAR(255)    |                            | 住客证件号码     |
            | is_primary_guest  | BOOLEAN         | 默认 FALSE                 | 是否为主要登记人 |

            4.3.2.11 访客登记表 (visitor_records)
            记录酒店访客的来访与离开信息。
            表4-11 访客登记表 (visitor_records)
            | 字段名称            | 数据类型        | 约束/索引      | 说明                 |
            |---------------------|-----------------|----------------|----------------------|
            | id                  | BIGINT          | 主键, 自增     | 访客记录ID           |
            | visitor_name        | VARCHAR(255)    | 非空           | 访客姓名             |
            | visitor_phone       | VARCHAR(50)     |                | 访客电话             |
            | visitor_id_number   | VARCHAR(255)    |                | 访客证件号(可选)     |
            | number_of_visitors  | INT             | 默认 1         | 访客人数             |
            | visited_guest_name  | VARCHAR(255)    |                | 被访客人姓名         |
            | visited_room_number | VARCHAR(50)     |                | 被访房间号           |
            | visit_reason        | TEXT            |                | 来访事由             |
            | entry_time          | DATETIME        | 非空           | 进入时间             |
            | expected_exit_time  | DATETIME        |                | 预计离开时间         |
            | actual_exit_time    | DATETIME        |                | 实际离开时间         |
            | registered_by_staff_id| BIGINT        | 外键(users)    | 登记员工ID           |
            | notes               | TEXT            |                | 备注                 |
            | create_time         | DATETIME        |                | 创建时间             |
            | update_time         | DATETIME        |                | 更新时间             |

            4.3.2.12 清洁任务表 (cleaning_tasks)
            记录房间的清洁任务和状态。
            表4-12 清洁任务表 (cleaning_tasks)
            | 字段名称          | 数据类型        | 约束/索引      | 说明               |
            |-------------------|-----------------|----------------|--------------------|
            | id                | BIGINT          | 主键, 自增     | 清洁任务ID         |
            | room_id           | BIGINT          | 非空, 外键(rooms)| 关联的房间ID       |
            | assigned_cleaner_id| BIGINT         | 外键(users), 可空 | 分配的清洁员ID     |
            | task_type         | VARCHAR(50)     | 非空           | 清洁类型 (如: CHECK_OUT_CLEAN, DAILY_CLEAN, DEEP_CLEAN) |
            | task_status       | VARCHAR(50)     | 非空, 默认PENDING | 任务状态 (如: PENDING, ASSIGNED, IN_PROGRESS, COMPLETED, CANCELLED) |
            | priority          | VARCHAR(20)     | 默认 NORMAL    | 优先级 (如: NORMAL, URGENT) |
            | request_time      | DATETIME        |                | 清洁请求生成时间   |
            | assigned_time     | DATETIME        |                | 任务分配时间       |
            | started_time      | DATETIME        |                | 清洁开始时间       |
            | completed_time    | DATETIME        |                | 清洁完成时间       |
            | notes_to_cleaner  | TEXT            |                | 给清洁员的备注     |
            | feedback_from_cleaner| TEXT         |                | 清洁员反馈/问题上报|
            | create_time       | DATETIME        |                | 创建时间           |
            | update_time       | DATETIME        |                | 更新时间           |
            
            4.3.2.13 会员等级定义表 (member_level_definitions)
            存储会员等级的规则和权益。
            表4-13 会员等级定义表 (member_level_definitions)
            | 字段名称        | 数据类型        | 约束/索引      | 说明               |
            |-----------------|-----------------|----------------|--------------------|
            | id              | BIGINT          | 主键, 自增     | 等级定义ID         |
            | level_name      | VARCHAR(100)    | 非空, 唯一     | 等级名称 (如: 普通会员, 银卡, 金卡, 钻石会员) |
            | min_points_to_reach| INT          | 默认 0         | 达到该等级所需最低积分 (条件之一) |
            | min_spent_to_reach| DECIMAL(12,2) | 默认 0.00      | 达到该等级所需最低累计消费 (条件之一) |
            | min_nights_to_reach| INT          | 默认 0         | 达到该等级所需最低入住晚数 (条件之一) |
            | discount_rate   | DECIMAL(4,3)    | 非空, 默认1.000 | 预订折扣率 (如0.950表示95折)|
            | points_multiplier| DECIMAL(3,2)   | 默认 1.00      | 积分获取乘数       |
            | description     | TEXT            |                | 等级权益详细描述   |
            | icon_url        | VARCHAR(500)    |                | 等级图标URL        |
            | sort_order      | INT             | 默认 0         | 等级排序 (数字越小越高级) |
            | create_time     | DATETIME        |                | 创建时间           |
            | update_time     | DATETIME        |                | 更新时间           |

            (根据实际的会员升级逻辑，User表中的`member_level_id`会参照此表。其他如支付记录表、系统操作日志表、评价与反馈表等可根据项目详细程度进一步补充。)

通过以上表结构设计，我们力求覆盖酒店核心业务流程的数据存储需求，同时兼顾了数据的规范性、一致性和未来扩展的可能性。清晰的表结构是系统稳定运行和高效查询的基础。




    5.2 核心功能模块实现
        在明确了开发环境与所需工具后，本节将详细阐述系统中几个核心功能模块的具体实现过程，包括前端的用户交互设计和后端的业务逻辑处理。我们将选取用户注册与登录、房间预订流程以及后台房间管理这三个具有代表性的模块进行说明，同时深入剖析每个功能的技术实现细节。

        5.2.1 用户注册与登录模块实现
            用户认证与授权是任何信息系统的安全基石。本系统通过Spring Security框架结合JWT（JSON Web Token）技术，实现了用户身份的验证与会话管理。整个模块设计既考虑了安全性，也注重了用户体验的流畅性。

            1. 用户注册流程：
            
            （1）前端实现 (Vue.js)：
                用户注册界面由一个独立的Vue组件（例如 Register.vue）构成，布局清晰，交互友好。该组件包含多个输入字段：用户名、密码（及确认密码）、真实姓名、手机号码、电子邮箱等。每个输入字段都有实时的客户端校验，确保用户在提交前就能获得及时反馈。

                代码示例（Register.vue部分代码）：
                ```vue
                <template>
                  <div class="register-container">
                    <h2>新用户注册</h2>
                    <el-form :model="registerForm" :rules="rules" ref="registerForm" label-width="100px">
                      <el-form-item label="用户名" prop="username">
                        <el-input v-model="registerForm.username" placeholder="请输入用户名（4-20个字符）"></el-input>
                      </el-form-item>
                      <el-form-item label="密码" prop="password">
                        <el-input type="password" v-model="registerForm.password" placeholder="请输入密码（8-20个字符）" 
                                  show-password></el-input>
                      </el-form-item>
                      <el-form-item label="确认密码" prop="confirmPassword">
                        <el-input type="password" v-model="registerForm.confirmPassword" placeholder="请再次输入密码" 
                                  show-password></el-input>
                      </el-form-item>
                      <el-form-item label="真实姓名" prop="name">
                        <el-input v-model="registerForm.name" placeholder="请输入您的真实姓名"></el-input>
                      </el-form-item>
                      <el-form-item label="手机号码" prop="phone">
                        <el-input v-model="registerForm.phone" placeholder="请输入您的手机号码"></el-input>
                      </el-form-item>
                      <el-form-item label="电子邮箱" prop="email">
                        <el-input v-model="registerForm.email" placeholder="请输入您的电子邮箱"></el-input>
                      </el-form-item>
                      <el-form-item>
                        <el-button type="primary" @click="submitRegistration" :loading="loading">立即注册</el-button>
                        <el-button @click="resetForm">重置</el-button>
                      </el-form-item>
                    </el-form>
                    <div class="login-link">
                      已有账号？<router-link to="/login">立即登录</router-link>
                    </div>
                  </div>
                </template>
                ```

                表单校验规则设计严谨，包括：用户名长度与格式校验（不允许特殊字符）、密码强度校验（要求包含字母、数字，长度8-20位）、两次密码输入一致性校验、邮箱格式与手机号码格式校验等。这些前端校验可以减轻服务器负担，提升用户体验。

                用户填写完毕并点击"注册"按钮后，前端会使用Axios库向后端API接口（例如 /api/users/register）发起一个POST请求，请求体中携带JSON格式的用户注册信息。为防止跨站请求伪造攻击，请求会自动携带CSRF令牌（如果系统配置了此安全措施）。

                提交注册的业务逻辑代码示例：
                ```javascript
                // Register.vue的<script setup>部分
                import { ref, reactive } from 'vue';
                import { useRouter } from 'vue-router';
                import { ElMessage } from 'element-plus';
                import api from '@/api/userApi';

                const router = useRouter();
                const registerForm = reactive({
                  username: '',
                  password: '',
                  confirmPassword: '',
                  name: '',
                  phone: '',
                  email: ''
                });
                const loading = ref(false);

                // 定义表单校验规则...（省略）

                const submitRegistration = async () => {
                  try {
                    loading.value = true;
                    // 调用后端API注册用户
                    const response = await api.register({
                      username: registerForm.username,
                      password: registerForm.password,
                      name: registerForm.name,
                      phone: registerForm.phone,
                      email: registerForm.email
                    });
                    
                    ElMessage.success('注册成功！请登录您的账号。');
                    // 注册成功后跳转到登录页
                    router.push('/login');
                  } catch (error) {
                    // 处理各种错误情况
                    if (error.response && error.response.data) {
                      ElMessage.error(error.response.data.message || '注册失败，请稍后重试');
                    } else {
                      ElMessage.error('网络错误，请检查您的网络连接');
                    }
                  } finally {
                    loading.value = false;
                  }
                };
                ```

                注册成功后，系统会引导用户进入登录页面；若失败，则显示相应的错误提示（如用户名已存在、邮箱已被注册等），并突出显示需要修正的表单项。
                
            （2）后端实现 (Spring Boot)：
                后端的用户注册功能主要由三层结构协同完成：Controller层接收请求，Service层处理业务逻辑，Repository层负责数据持久化。

                在Controller层，UserController（或专门的AuthController）定义了处理/register请求的方法。该方法通过@PostMapping注解绑定到POST /api/users/register端点。为提高代码的可读性和可维护性，注册请求数据被封装在专门设计的DTO（数据传输对象）中。
                
                UserController代码示例：
                ```java
                @RestController
                @RequestMapping("/api/users")
                public class UserController {
                    
                    private final UserService userService;
                    
                    @Autowired
                    public UserController(UserService userService) {
                        this.userService = userService;
                    }
                    
                    @PostMapping("/register")
                    public ResponseEntity<?> registerUser(@Valid @RequestBody UserRegistrationDto registrationDto, 
                                                         BindingResult bindingResult) {
                        // 校验表单数据
                        if (bindingResult.hasErrors()) {
                            Map<String, String> errors = new HashMap<>();
                            bindingResult.getFieldErrors().forEach(error -> 
                                errors.put(error.getField(), error.getDefaultMessage())
                            );
                            return ResponseEntity.badRequest().body(new ApiResponse(false, "表单验证失败", errors));
                        }
                        
                        try {
                            UserDto createdUser = userService.registerUser(registrationDto);
                            return ResponseEntity.status(HttpStatus.CREATED)
                                .body(new ApiResponse(true, "用户注册成功", createdUser));
                        } catch (UserAlreadyExistsException e) {
                            return ResponseEntity.badRequest()
                                .body(new ApiResponse(false, e.getMessage()));
                        } catch (Exception e) {
                            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(new ApiResponse(false, "注册过程中发生错误，请稍后重试"));
                        }
                    }
                }
                ```

                UserRegistrationDto是一个专门用于接收注册表单数据的类，它包含用户名、密码等字段，并使用Java Bean Validation注解（@NotBlank、@Size、@Email等）定义校验规则。

                ```java
                public class UserRegistrationDto {
                    @NotBlank(message = "用户名不能为空")
                    @Size(min = 4, max = 20, message = "用户名长度必须在4-20个字符之间")
                    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "用户名只能包含字母、数字和下划线")
                    private String username;
                    
                    @NotBlank(message = "密码不能为空")
                    @Size(min = 8, max = 20, message = "密码长度必须在8-20个字符之间")
                    private String password;
                    
                    @NotBlank(message = "真实姓名不能为空")
                    private String name;
                    
                    @NotBlank(message = "手机号不能为空")
                    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
                    private String phone;
                    
                    @NotBlank(message = "邮箱不能为空")
                    @Email(message = "邮箱格式不正确")
                    private String email;
                    
                    // Getters and setters...
                }
                ```

                在Service层，UserService接口的实现类UserServiceImpl中，registerUser方法执行核心业务逻辑：

                ```java
                @Service
                public class UserServiceImpl implements UserService {
                    
                    private final UserRepository userRepository;
                    private final PasswordEncoder passwordEncoder;
                    private final ModelMapper modelMapper;
                    
                    @Autowired
                    public UserServiceImpl(UserRepository userRepository, 
                                         PasswordEncoder passwordEncoder,
                                         ModelMapper modelMapper) {
                        this.userRepository = userRepository;
                        this.passwordEncoder = passwordEncoder;
                        this.modelMapper = modelMapper;
                    }
                    
                    @Override
                    public UserDto registerUser(UserRegistrationDto registrationDto) {
                        // 1. 检查用户名是否已存在
                        if (userRepository.existsByUsername(registrationDto.getUsername())) {
                            throw new UserAlreadyExistsException("用户名已被注册");
                        }
                        
                        // 2. 检查邮箱是否已存在
                        if (userRepository.existsByEmail(registrationDto.getEmail())) {
                            throw new UserAlreadyExistsException("该邮箱已被注册");
                        }
                        
                        // 3. 检查手机号是否已存在
                        if (userRepository.existsByPhone(registrationDto.getPhone())) {
                            throw new UserAlreadyExistsException("该手机号已被注册");
                        }
                        
                        // 4. 创建新用户实体
                        User user = new User();
                        user.setUsername(registrationDto.getUsername());
                        // 对密码进行加盐哈希加密
                        user.setPassword(passwordEncoder.encode(registrationDto.getPassword()));
                        user.setName(registrationDto.getName());
                        user.setPhone(registrationDto.getPhone());
                        user.setEmail(registrationDto.getEmail());
                        
                        // 5. 设置默认角色为顾客
                        user.setRole(UserRole.CUSTOMER);
                        
                        // 6. 设置其他默认值
                        user.setStatus(UserStatus.ACTIVE);
                        user.setMemberLevel(MemberLevel.REGULAR);
                        user.setPoints(0);
                        user.setTotalSpent(BigDecimal.ZERO);
                        user.setCreateTime(LocalDateTime.now());
                        
                        // 7. 保存用户到数据库
                        User savedUser = userRepository.save(user);
                        
                        // 8. 转换为DTO并返回（排除敏感字段如密码）
                        return modelMapper.map(savedUser, UserDto.class);
                    }
                }
                ```

                密码加密是保障系统安全的关键环节。我们利用Spring Security提供的BCryptPasswordEncoder进行密码的加盐哈希处理，生成的密码哈希值将存储在数据库中。BCrypt算法的优势在于它集成了盐值处理，并且计算过程故意设计得较慢，这使得暴力破解变得极为困难。即使数据库被泄露，攻击者也难以快速解密用户密码。

                在数据层，UserRepository接口扩展了JpaRepository，提供了对User实体的基础CRUD操作以及一些自定义查询方法：

                ```java
                @Repository
                public interface UserRepository extends JpaRepository<User, Long> {
                    Optional<User> findByUsername(String username);
                    boolean existsByUsername(String username);
                    boolean existsByEmail(String email);
                    boolean existsByPhone(String phone);
                }
                ```

                User实体类是对应数据库users表的Java对象映射，使用JPA注解定义了实体结构：

                ```java
                @Entity
                @Table(name = "users")
                public class User {
                    @Id
                    @GeneratedValue(strategy = GenerationType.IDENTITY)
                    private Long id;
                    
                    @Column(nullable = false, unique = true)
                    private String username;
                    
                    @Column(nullable = false)
                    private String password;
                    
                    @Column(nullable = false)
                    private String name;
                    
                    @Column
                    private String phone;
                    
                    @Column(nullable = false, unique = true)
                    private String email;
                    
                    @Enumerated(EnumType.STRING)
                    @Column(nullable = false)
                    private UserRole role;
                    
                    @Enumerated(EnumType.STRING)
                    @Column(nullable = false)
                    private UserStatus status;
                    
                    @Enumerated(EnumType.STRING)
                    @Column(nullable = false)
                    private MemberLevel memberLevel;
                    
                    @Column(nullable = false)
                    private Integer points;
                    
                    @Column(nullable = false, precision = 10, scale = 2)
                    private BigDecimal totalSpent;
                    
                    @Column
                    private LocalDateTime createTime;
                    
                    @Column
                    private LocalDateTime updateTime;
                    
                    // Getters and setters, equals, hashCode, toString methods...
                }
                ```

            2. 用户登录流程：
            
            （1）前端实现 (Vue.js)：
                登录界面（Login.vue）提供简洁明了的输入表单，包含用户名和密码字段，以及"记住我"选项。界面设计注重用户体验，表单验证即时反馈，同时提供忘记密码和注册入口链接，方便用户快速切换操作意图。

                登录表单代码示例：
                ```vue
                <template>
                  <div class="login-container">
                    <h2>用户登录</h2>
                    <el-form :model="loginForm" :rules="rules" ref="loginForm">
                      <el-form-item prop="username">
                        <el-input v-model="loginForm.username" prefix-icon="el-icon-user" placeholder="请输入用户名"></el-input>
                      </el-form-item>
                      <el-form-item prop="password">
                        <el-input type="password" v-model="loginForm.password" prefix-icon="el-icon-lock" 
                                 placeholder="请输入密码" show-password @keyup.enter="handleLogin"></el-input>
                      </el-form-item>
                      <el-form-item>
                        <el-checkbox v-model="loginForm.remember">记住我</el-checkbox>
                        <router-link to="/forgot-password" class="forget-pwd">忘记密码？</router-link>
                      </el-form-item>
                      <el-form-item>
                        <el-button type="primary" :loading="loading" @click="handleLogin" style="width: 100%">登录</el-button>
                      </el-form-item>
                    </el-form>
                    <div class="register-link">
                      还没有账号？<router-link to="/register">立即注册</router-link>
                    </div>
                  </div>
                </template>
                ```

                登录业务逻辑的实现涉及状态管理和路由控制：
                ```javascript
                // Login.vue的<script setup>部分
                import { ref, reactive } from 'vue';
                import { useRouter } from 'vue-router';
                import { useUserStore } from '@/stores/user';
                import { ElMessage } from 'element-plus';
                import api from '@/api/userApi';

                const router = useRouter();
                const userStore = useUserStore();
                const loginForm = reactive({
                  username: '',
                  password: '',
                  remember: false
                });
                const loading = ref(false);

                // 表单校验规则...（省略）

                const handleLogin = async () => {
                  try {
                    loading.value = true;
                    // 调用登录API
                    const response = await api.login({
                      username: loginForm.username,
                      password: loginForm.password
                    });
                    
                    // 登录成功，保存JWT和用户信息
                    const { token, user } = response.data;
                    
                    // 使用Pinia存储用户状态
                    userStore.setToken(token);
                    userStore.setUser(user);
                    
                    // 根据"记住我"选项决定token存储方式
                    if (loginForm.remember) {
                      localStorage.setItem('token', token);
                    } else {
                      sessionStorage.setItem('token', token);
                    }
                    
                    ElMessage.success('登录成功');
                    
                    // 根据用户角色重定向到不同页面
                    if (user.role === 'ADMIN') {
                      router.push('/admin/dashboard');
                    } else if (user.role === 'RECEPTIONIST') {
                      router.push('/front-desk/home');
                    } else {
                      router.push('/user/home');
                    }
                  } catch (error) {
                    if (error.response && error.response.status === 401) {
                      ElMessage.error('用户名或密码错误');
                    } else {
                      ElMessage.error('登录失败，请稍后重试');
                    }
                    console.error('Login error:', error);
                  } finally {
                    loading.value = false;
                  }
                };
                ```

                登录成功后的JWT存储和请求拦截配置：
                在登录成功后，前端会将服务器返回的JWT存储到localStorage（如果选择了"记住我"）或sessionStorage中。同时，使用Pinia状态管理库对用户状态进行集中管理，便于在不同组件间共享用户信息。

                ```javascript
                // Axios请求拦截器配置
                import axios from 'axios';

                const apiClient = axios.create({
                  baseURL: process.env.VUE_APP_API_BASE_URL,
                  timeout: 10000,
                  headers: {
                    'Content-Type': 'application/json'
                  }
                });

                // 请求拦截器：自动添加JWT到请求头
                apiClient.interceptors.request.use(
                  config => {
                    const token = localStorage.getItem('token') || sessionStorage.getItem('token');
                    if (token) {
                      config.headers['Authorization'] = `Bearer ${token}`;
                    }
                    return config;
                  },
                  error => {
                    return Promise.reject(error);
                  }
                );

                // 响应拦截器：处理401未授权错误（JWT过期）
                apiClient.interceptors.response.use(
                  response => response,
                  error => {
                    if (error.response && error.response.status === 401) {
                      // 清除用户状态并重定向到登录页
                      localStorage.removeItem('token');
                      sessionStorage.removeItem('token');
                      window.location.href = '/login?expired=true';
                    }
                    return Promise.reject(error);
                  }
                );

                export default apiClient;
                ```
                
            （2）后端实现 (Spring Boot)：
                在后端，登录认证逻辑涉及Spring Security框架的多个组件，包括认证管理器（AuthenticationManager）、用户详情服务（UserDetailsService）和JWT处理工具。

                首先，AuthController定义了登录API端点：
                ```java
                @RestController
                @RequestMapping("/api/auth")
                public class AuthController {
                    
                    private final AuthenticationManager authenticationManager;
                    private final JwtTokenProvider jwtTokenProvider;
                    private final UserService userService;
                    
                    @Autowired
                    public AuthController(AuthenticationManager authenticationManager,
                                        JwtTokenProvider jwtTokenProvider,
                                        UserService userService) {
                        this.authenticationManager = authenticationManager;
                        this.jwtTokenProvider = jwtTokenProvider;
                        this.userService = userService;
                    }
                    
                    @PostMapping("/login")
                    public ResponseEntity<?> authenticateUser(@Valid @RequestBody LoginRequest loginRequest) {
                        try {
                            // 尝试认证用户
                            Authentication authentication = authenticationManager.authenticate(
                                new UsernamePasswordAuthenticationToken(
                                    loginRequest.getUsername(),
                                    loginRequest.getPassword()
                                )
                            );
                            
                            // 认证成功，设置安全上下文
                            SecurityContextHolder.getContext().setAuthentication(authentication);
                            
                            // 生成JWT令牌
                            String jwt = jwtTokenProvider.generateToken(authentication);
                            
                            // 获取用户详情（排除敏感字段）
                            UserDetails userDetails = (UserDetails) authentication.getPrincipal();
                            UserDto userDto = userService.getUserByUsername(userDetails.getUsername());
                            
                            // 返回JWT和用户信息
                            return ResponseEntity.ok(new JwtAuthenticationResponse(jwt, userDto));
                        } catch (BadCredentialsException e) {
                            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                                .body(new ApiResponse(false, "用户名或密码错误"));
                        } catch (Exception e) {
                            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(new ApiResponse(false, "登录过程中发生错误，请稍后重试"));
                        }
                    }
                    
                    // 其他认证相关端点（如刷新令牌、登出等）...
                }
                ```

                登录请求DTO和响应DTO：
                ```java
                public class LoginRequest {
                    @NotBlank
                    private String username;
                    
                    @NotBlank
                    private String password;
                    
                    // Getters and setters...
                }

                public class JwtAuthenticationResponse {
                    private String token;
                    private String tokenType = "Bearer";
                    private UserDto user;
                    
                    public JwtAuthenticationResponse(String token, UserDto user) {
                        this.token = token;
                        this.user = user;
                    }
                    
                    // Getters and setters...
                }
                ```

                JwtTokenProvider类是处理JWT生成、验证和解析的核心组件：
                ```java
                @Component
                public class JwtTokenProvider {
                    private static final Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);
                    
                    @Value("${app.jwt.secret}")
                    private String jwtSecret;
                    
                    @Value("${app.jwt.expiration}")
                    private int jwtExpirationInMs;
                    
                    // 从用户认证信息生成JWT
                    public String generateToken(Authentication authentication) {
                        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
                        
                        Date now = new Date();
                        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);
                        
                        return Jwts.builder()
                            .setSubject(userDetails.getUsername())
                            .setIssuedAt(new Date())
                            .setExpiration(expiryDate)
                            .signWith(SignatureAlgorithm.HS512, jwtSecret)
                            .compact();
                    }
                    
                    // 从JWT中提取用户名
                    public String getUsernameFromJWT(String token) {
                        Claims claims = Jwts.parser()
                            .setSigningKey(jwtSecret)
                            .parseClaimsJws(token)
                            .getBody();
                        
                        return claims.getSubject();
                    }
                    
                    // 验证JWT有效性
                    public boolean validateToken(String authToken) {
                        try {
                            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);
                            return true;
                        } catch (SignatureException ex) {
                            logger.error("无效的JWT签名");
                        } catch (MalformedJwtException ex) {
                            logger.error("无效的JWT令牌");
                        } catch (ExpiredJwtException ex) {
                            logger.error("JWT令牌已过期");
                        } catch (UnsupportedJwtException ex) {
                            logger.error("不支持的JWT令牌");
                        } catch (IllegalArgumentException ex) {
                            logger.error("JWT声明为空");
                        }
                        return false;
                    }
                }
                ```

                为了让Spring Security能够识别和加载用户信息，需要实现UserDetailsService接口：
                ```java
                @Service
                public class CustomUserDetailsService implements UserDetailsService {
                    
                    private final UserRepository userRepository;
                    
                    @Autowired
                    public CustomUserDetailsService(UserRepository userRepository) {
                        this.userRepository = userRepository;
                    }
                    
                    @Override
                    @Transactional(readOnly = true)
                    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
                        User user = userRepository.findByUsername(username)
                            .orElseThrow(() -> 
                                new UsernameNotFoundException("无法找到用户名为 " + username + " 的用户")
                            );
                        
                        // 检查用户状态
                        if (user.getStatus() != UserStatus.ACTIVE) {
                            throw new DisabledException("该账户已被禁用");
                        }
                        
                        // 构建Spring Security的UserDetails对象
                        return new org.springframework.security.core.userdetails.User(
                            user.getUsername(),
                            user.getPassword(),
                            getAuthorities(user.getRole())
                        );
                    }
                    
                    private Collection<? extends GrantedAuthority> getAuthorities(UserRole role) {
                        return Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + role.name()));
                    }
                }
                ```

                最后，需要配置Spring Security的安全过滤链，并添加自定义的JWT认证过滤器：
                ```java
                @Configuration
                @EnableWebSecurity
                @EnableGlobalMethodSecurity(
                    securedEnabled = true,
                    jsr250Enabled = true,
                    prePostEnabled = true
                )
                public class SecurityConfig extends WebSecurityConfigurerAdapter {
                    
                    @Autowired
                    private CustomUserDetailsService customUserDetailsService;
                    
                    @Autowired
                    private JwtAuthenticationEntryPoint unauthorizedHandler;
                    
                    @Bean
                    public JwtAuthenticationFilter jwtAuthenticationFilter() {
                        return new JwtAuthenticationFilter();
                    }
                    
                    @Override
                    public void configure(AuthenticationManagerBuilder auth) throws Exception {
                        auth
                            .userDetailsService(customUserDetailsService)
                            .passwordEncoder(passwordEncoder());
                    }
                    
                    @Bean
                    @Override
                    public AuthenticationManager authenticationManagerBean() throws Exception {
                        return super.authenticationManagerBean();
                    }
                    
                    @Bean
                    public PasswordEncoder passwordEncoder() {
                        return new BCryptPasswordEncoder();
                    }
                    
                    @Override
                    protected void configure(HttpSecurity http) throws Exception {
                        http
                            .cors()
                                .and()
                            .csrf()
                                .disable()
                            .exceptionHandling()
                                .authenticationEntryPoint(unauthorizedHandler)
                                .and()
                            .sessionManagement()
                                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                                .and()
                            .authorizeRequests()
                                .antMatchers("/api/auth/**", "/api/users/register")
                                    .permitAll()
                                .antMatchers("/api/public/**")
                                    .permitAll()
                                .antMatchers("/api/admin/**")
                                    .hasRole("ADMIN")
                                .antMatchers("/api/receptionist/**")
                                    .hasAnyRole("ADMIN", "RECEPTIONIST")
                                .anyRequest()
                                    .authenticated();
                        
                        // 添加JWT认证过滤器
                        http.addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
                    }
                }
                ```

                JWT认证过滤器会拦截所有请求，从请求头中提取和验证JWT，并根据JWT中的用户信息设置当前请求的认证上下文：
                ```java
                public class JwtAuthenticationFilter extends OncePerRequestFilter {
                    
                    @Autowired
                    private JwtTokenProvider tokenProvider;
                    
                    @Autowired
                    private CustomUserDetailsService customUserDetailsService;
                    
                    private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);
                    
                    @Override
                    protected void doFilterInternal(HttpServletRequest request, 
                                                  HttpServletResponse response, 
                                                  FilterChain filterChain) 
                                                  throws ServletException, IOException {
                        try {
                            String jwt = getJwtFromRequest(request);
                            
                            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                                String username = tokenProvider.getUsernameFromJWT(jwt);
                                
                                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);
                                UsernamePasswordAuthenticationToken authentication = 
                                    new UsernamePasswordAuthenticationToken(
                                        userDetails, null, userDetails.getAuthorities());
                                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                                
                                SecurityContextHolder.getContext().setAuthentication(authentication);
                            }
                        } catch (Exception ex) {
                            logger.error("无法设置用户认证", ex);
                        }
                        
                        filterChain.doFilter(request, response);
                    }
                    
                    private String getJwtFromRequest(HttpServletRequest request) {
                        String bearerToken = request.getHeader("Authorization");
                        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
                            return bearerToken.substring(7);
                        }
                        return null;
                    }
                }
                ```

            3. JWT令牌的运用与安全：
                在本系统中，JWT承担了用户会话管理的核心角色。它是一种自包含的令牌，由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。

                采用JWT的主要优势包括：
                1. 无状态认证：服务器不需要维护会话状态，降低了服务器资源消耗，特别适合分布式系统。
                2. 跨域支持：天然支持跨域认证，适合前后端分离架构。
                3. 防伪造保护：通过数字签名确保令牌内容不被篡改。

                为增强JWT的安全性，我们实施了多项保护措施：
                - 密钥保护：JWT签名密钥妥善保存在服务器配置中，不在代码中硬编码。
                - 合理的过期时间：令牌设置了较短的有效期（如1小时），减少被盗用的风险窗口。
                - 敏感信息处理：载荷中不存储敏感信息（如密码）。
                - 传输安全：在生产环境中，所有API请求通过HTTPS加密传输。
                - 刷新令牌机制：实现了刷新令牌（Refresh Token）API，允许客户端在JWT即将过期时获取新令牌，避免用户频繁登录。

                刷新令牌示例代码：
                ```java
                @PostMapping("/refresh-token")
                public ResponseEntity<?> refreshToken(@Valid @RequestBody RefreshTokenRequest request) {
                    // 验证旧令牌的签名（即使已过期）
                    try {
                        String username = tokenProvider.getUsernameFromExpiredJWT(request.getToken());
                        UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);
                        
                        // 生成新令牌
                        UsernamePasswordAuthenticationToken authentication = 
                            new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                        String newToken = tokenProvider.generateToken(authentication);
                        
                        return ResponseEntity.ok(new JwtAuthenticationResponse(newToken, null));
                    } catch (Exception e) {
                        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                            .body(new ApiResponse(false, "令牌刷新失败，请重新登录"));
                    }
                }
                ```

        5.2.2 房间预订流程实现
            房间预订是酒店系统的核心业务流程，直接关系到客户体验和酒店收益。本系统实现了完整的在线预订流程，包括房型浏览、可用性查询、创建订单等环节。

            1. 房型浏览与可用性查询：
            
                       （1）前端实现 (Vue.js)：
                房型展示页面（RoomListing.vue）采用响应式设计，在不同设备上都能提供良好的浏览体验。页面顶部设有日期选择区域，让用户可以方便地指定入住和离店日期，以及入住人数等筛选条件。

                房型列表使用Element Plus的Card组件以网格布局展示，每个房型卡片包含：
                - 房型主图（可点击查看更多图片）
                - 房型名称和简短描述
                - 最大可入住人数和床型信息
                - 房间面积和主要设施图标
                - 价格信息（可根据选择的日期显示实时价格）
                - "查看详情"和"立即预订"按钮

                下面是房型列表组件的核心代码示例：
                ```vue
                <template>
                  <div class="room-listing">
                    <!-- 搜索与筛选面板 -->
                    <el-card class="search-panel">
                      <div class="date-picker-container">
                        <el-date-picker
                          v-model="dateRange"
                          type="daterange"
                          range-separator="至"
                          start-placeholder="入住日期"
                          end-placeholder="离店日期"
                          :disabled-date="disabledDate"
                          @change="handleDateChange"
                        />
                      </div>
                      <div class="guest-counter">
                        <el-input-number v-model="guestCount" :min="1" :max="10" @change="handleSearch" />
                        <span class="label">入住人数</span>
                      </div>
                      <el-button type="primary" @click="handleSearch">查询</el-button>
                    </el-card>

                    <!-- 房型列表 -->
                    <div v-if="loading" class="loading-container">
                      <el-skeleton :rows="3" animated />
                    </div>
                    <div v-else class="room-grid">
                      <el-empty v-if="roomTypes.length === 0" description="暂无可用房型"></el-empty>
                      <el-card v-for="room in roomTypes" :key="room.id" class="room-card">
                        <div class="room-image" @click="showGallery(room)">
                          <img :src="room.mainImage" :alt="room.name">
                          <div class="image-overlay">
                            <i class="el-icon-picture-outline"></i> 查看更多图片
                          </div>
                        </div>
                        <div class="room-info">
                          <h3>{{ room.name }}</h3>
                          <p class="description">{{ room.shortDescription }}</p>
                          <div class="capacity-info">
                            <i class="el-icon-user"></i> 最多{{ room.capacity }}人
                            <span class="divider">|</span>
                            <i class="el-icon-house"></i> {{ room.area }}㎡
                          </div>
                          <div class="bed-info">
                            <i class="el-icon-moon"></i> {{ room.bedType }}
                          </div>
                          <div class="facilities">
                            <i v-for="facility in room.facilities" :key="facility"
                               :class="facilityIcons[facility]" 
                               :title="facilityNames[facility]"></i>
                          </div>
                          <div class="price-container">
                            <div class="price">
                              <span class="currency">￥</span>
                              <span class="amount">{{ room.currentPrice }}</span>
                              <span class="unit">/晚</span>
                            </div>
                            <div class="room-actions">
                              <el-button size="small" @click="viewRoomDetail(room.id)">查看详情</el-button>
                              <el-button type="primary" size="small" @click="bookNow(room)">立即预订</el-button>
                            </div>
                          </div>
                        </div>
                      </el-card>
                    </div>
                  </div>
                </template>
                ```

                在房型搜索和展示逻辑中，关键业务代码如下：
                ```javascript
                import { ref, reactive, computed, onMounted, watch } from 'vue';
                import { useRouter } from 'vue-router';
                import { ElMessage } from 'element-plus';
                import api from '@/api/roomApi';
                import { formatDate } from '@/utils/dateUtils';

                const dateRange = ref([new Date(), addDays(new Date(), 1)]);
                const guestCount = ref(2);
                const roomTypes = ref([]);
                const loading = ref(false);

                // 获取可用房型列表
                const fetchAvailableRoomTypes = async () => {
                  if (!dateRange.value || !dateRange.value[0] || !dateRange.value[1]) {
                    ElMessage.warning('请选择入住和离店日期');
                    return;
                  }
                  
                  try {
                    loading.value = true;
                    const params = {
                      checkInDate: formatDate(dateRange.value[0]),
                      checkOutDate: formatDate(dateRange.value[1]),
                      guestCount: guestCount.value
                    };
                    
                    const response = await api.getAvailableRoomTypes(params);
                    roomTypes.value = response.data;
                    
                    // 处理房型数据，确保UI显示所需的所有字段都存在
                    roomTypes.value = roomTypes.value.map(room => ({
                      ...room,
                      mainImage: room.images && room.images.length > 0 
                          ? room.images[0] 
                          : '/images/room-placeholder.jpg',
                      shortDescription: truncateText(room.description, 100),
                      facilities: room.amenities ? room.amenities.split(',') : []
                    }));
                  } catch (error) {
                    console.error('Failed to fetch room types:', error);
                    ElMessage.error('获取房型信息失败，请稍后重试');
                    roomTypes.value = [];
                  } finally {
                    loading.value = false;
                  }
                };

                // 禁用今天之前的日期
                const disabledDate = (time) => {
                  return time.getTime() < Date.now() - 8.64e7; // 禁用今天之前的日期
                };

                // 处理日期变更
                const handleDateChange = () => {
                  // 确保离店日期在入住日期之后
                  if (dateRange.value && dateRange.value[0] && dateRange.value[1]) {
                    if (dateRange.value[0] >= dateRange.value[1]) {
                      dateRange.value[1] = addDays(dateRange.value[0], 1);
                    }
                  }
                  handleSearch();
                };

                // 执行搜索
                const handleSearch = () => {
                  fetchAvailableRoomTypes();
                };

                // 查看房型详情
                const router = useRouter();
                const viewRoomDetail = (roomTypeId) => {
                  router.push({
                    name: 'RoomDetail',
                    params: { id: roomTypeId },
                    query: {
                      checkIn: formatDate(dateRange.value[0]),
                      checkOut: formatDate(dateRange.value[1]),
                      guests: guestCount.value
                    }
                  });
                };

                // 跳转到预订页面
                const bookNow = (room) => {
                  if (!dateRange.value || !dateRange.value[0] || !dateRange.value[1]) {
                    ElMessage.warning('请先选择入住和离店日期');
                    return;
                  }
                  
                  router.push({
                    name: 'CreateReservation',
                    params: { roomTypeId: room.id },
                    query: {
                      checkIn: formatDate(dateRange.value[0]),
                      checkOut: formatDate(dateRange.value[1]),
                      guests: guestCount.value
                    }
                  });
                };

                onMounted(() => {
                  // 尝试从URL参数恢复搜索条件
                  const query = route.query;
                  if (query.checkIn && query.checkOut) {
                    dateRange.value = [new Date(query.checkIn), new Date(query.checkOut)];
                  }
                  if (query.guests) {
                    guestCount.value = parseInt(query.guests, 10) || 2;
                  }
                  
                  fetchAvailableRoomTypes();
                });
                ```

                当用户点击特定房型的"查看详情"链接，系统会导航到该房型的详情页（RoomDetail.vue），展示更多图片、详细描述、设施列表、服务政策等信息，同时保留用户选择的日期和人数，提供"立即预订"按钮以继续预订流程。

            （2）后端实现 (Spring Boot)：
                后端的房型查询与可用性检查主要由RoomTypeController和RoomService协同完成。首先，RoomTypeController提供了API端点：

                ```java
                @RestController
                @RequestMapping("/api/room-types")
                public class RoomTypeController {
                    
                    private final RoomService roomService;
                    
                    @Autowired
                    public RoomTypeController(RoomService roomService) {
                        this.roomService = roomService;
                    }
                    
                    // 获取所有房型（不带可用性检查，仅用于浏览）
                    @GetMapping
                    public ResponseEntity<List<RoomTypeDto>> getAllRoomTypes() {
                        List<RoomTypeDto> roomTypes = roomService.getAllRoomTypes();
                        return ResponseEntity.ok(roomTypes);
                    }
                    
                    // 获取单个房型详情
                    @GetMapping("/{id}")
                    public ResponseEntity<RoomTypeDto> getRoomTypeById(@PathVariable Long id) {
                        RoomTypeDto roomType = roomService.getRoomTypeById(id);
                        return ResponseEntity.ok(roomType);
                    }
                    
                    // 查询指定日期范围内可用的房型
                    @GetMapping("/available")
                    public ResponseEntity<List<AvailableRoomTypeDto>> getAvailableRoomTypes(
                            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate checkInDate,
                            @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate checkOutDate,
                            @RequestParam(required = false, defaultValue = "1") Integer guestCount) {
                        
                        // 基础参数验证
                        if (checkInDate.isBefore(LocalDate.now())) {
                            return ResponseEntity.badRequest().body(null);
                        }
                        
                        if (checkOutDate.isBefore(checkInDate) || checkOutDate.isEqual(checkInDate)) {
                            return ResponseEntity.badRequest().body(null);
                        }
                        
                        List<AvailableRoomTypeDto> availableRoomTypes = 
                            roomService.findAvailableRoomTypes(checkInDate, checkOutDate, guestCount);
                        
                        return ResponseEntity.ok(availableRoomTypes);
                    }
                }
                ```

                RoomService的核心方法是findAvailableRoomTypes，它实现了复杂的可用性检查逻辑：

                ```java
                @Service
                public class RoomServiceImpl implements RoomService {
                    
                    private final RoomTypeRepository roomTypeRepository;
                    private final RoomRepository roomRepository;
                    private final ReservationRepository reservationRepository;
                    private final CheckInRecordRepository checkInRecordRepository;
                    private final ModelMapper modelMapper;
                    
                    @Autowired
                    public RoomServiceImpl(RoomTypeRepository roomTypeRepository,
                                          RoomRepository roomRepository,
                                          ReservationRepository reservationRepository,
                                          CheckInRecordRepository checkInRecordRepository,
                                          ModelMapper modelMapper) {
                        this.roomTypeRepository = roomTypeRepository;
                        this.roomRepository = roomRepository;
                        this.reservationRepository = reservationRepository;
                        this.checkInRecordRepository = checkInRecordRepository;
                        this.modelMapper = modelMapper;
                    }
                    
                    // 查找特定日期范围内可用的房型
                    @Override
                    public List<AvailableRoomTypeDto> findAvailableRoomTypes(
                            LocalDate checkInDate, LocalDate checkOutDate, Integer guestCount) {
                        
                        // 1. 获取所有活跃状态的房型
                        List<RoomType> allRoomTypes = roomTypeRepository.findByStatus(RoomTypeStatus.AVAILABLE);
                        
                        // 2. 获取日期范围内不可用的房间ID
                        Set<Long> unavailableRoomIds = new HashSet<>();
                        
                        // 2.1 查找日期范围内已有预订且状态为确认、待入住的房间
                        List<Reservation> conflictingReservations = reservationRepository
                            .findConflictingReservations(checkInDate, checkOutDate);
                        
                        for (Reservation reservation : conflictingReservations) {
                            if (reservation.getRoom() != null) {
                                unavailableRoomIds.add(reservation.getRoom().getId());
                            }
                        }
                        
                        // 2.2 查找当前已入住但在查询的日期范围内的房间
                        List<CheckInRecord> currentCheckIns = checkInRecordRepository
                            .findCurrentCheckIns(checkInDate, checkOutDate);
                        
                        for (CheckInRecord checkIn : currentCheckIns) {
                            unavailableRoomIds.add(checkIn.getRoom().getId());
                        }
                        
                        // 2.3 查找状态不为可用的房间（如维修中）
                        List<Room> unavailableRooms = roomRepository
                            .findByStatusNot(RoomStatus.AVAILABLE);
                        
                        for (Room room : unavailableRooms) {
                            unavailableRoomIds.add(room.getId());
                        }
                        
                        // 3. 计算每种房型的可用数量
                        Map<Long, Integer> roomTypeAvailabilityMap = new HashMap<>();
                        
                        // 3.1 先统计每种房型的总房间数
                        List<Room> allRooms = roomRepository.findAll();
                        for (Room room : allRooms) {
                            Long roomTypeId = room.getRoomType().getId();
                            roomTypeAvailabilityMap.put(
                                roomTypeId, 
                                roomTypeAvailabilityMap.getOrDefault(roomTypeId, 0) + 1
                            );
                        }
                        
                        // 3.2 减去不可用的房间数
                        for (Room room : allRooms) {
                            if (unavailableRoomIds.contains(room.getId())) {
                                Long roomTypeId = room.getRoomType().getId();
                                roomTypeAvailabilityMap.put(
                                    roomTypeId, 
                                    roomTypeAvailabilityMap.getOrDefault(roomTypeId, 0) - 1
                                );
                            }
                        }
                        
                        // 4. 构建返回结果（仅包含有可用房间的房型）
                        List<AvailableRoomTypeDto> result = new ArrayList<>();
                        
                        for (RoomType roomType : allRoomTypes) {
                            int availableCount = roomTypeAvailabilityMap.getOrDefault(roomType.getId(), 0);
                            
                            // 仅当有可用房间且满足入住人数要求时才返回
                            if (availableCount > 0 && roomType.getCapacity() >= guestCount) {
                                AvailableRoomTypeDto dto = modelMapper.map(roomType, AvailableRoomTypeDto.class);
                                dto.setAvailableCount(availableCount);
                                
                                // 计算该日期范围内的价格
                                BigDecimal price = calculateRoomPrice(roomType, checkInDate, checkOutDate);
                                dto.setCurrentPrice(price);
                                
                                result.add(dto);
                            }
                        }
                        
                        return result;
                    }
                    
                    // 计算房间在指定日期范围内的价格
                    private BigDecimal calculateRoomPrice(RoomType roomType, LocalDate checkInDate, LocalDate checkOutDate) {
                        // 这里可以实现更复杂的定价逻辑，如区分平日/周末/节假日价格
                        // 简化版：使用基础价格
                        return roomType.getBasePrice();
                    }
                    
                    // 其他方法...
                }
                ```

                此实现考虑了多种因素来确定房间可用性：
                - 当前已有的确认预订
                - 当前的入住记录
                - 房间状态（如维修中的房间）
                
                这种实现确保了系统不会超售房间，同时为用户提供准确的可用房型信息和实时价格。

            2. 创建预订订单：
            
            （1）前端实现 (Vue.js)：
                当用户选择了满意的房型后，系统引导至预订信息填写页面（CreateReservation.vue）。该页面分为几个主要部分：
                - 左侧：预订摘要（所选房型、日期、价格）
                - 右侧：预订信息表单（联系人信息、入住人信息等）
                
                预订表单的实现代码示例：
                ```vue
                <template>
                  <div class="reservation-container">
                    <el-row :gutter="20">
                      <!-- 左侧：预订摘要 -->
                      <el-col :span="8">
                        <el-card class="booking-summary">
                          <h3>预订摘要</h3>
                          <div class="room-info">
                            <img :src="roomType.mainImage" :alt="roomType.name" class="room-image">
                            <h4>{{ roomType.name }}</h4>
                            <div class="stay-details">
                              <p><i class="el-icon-date"></i> 入住: {{ formatDate(checkInDate) }}</p>
                              <p><i class="el-icon-date"></i> 退房: {{ formatDate(checkOutDate) }}</p>
                              <p><i class="el-icon-time"></i> 共 {{ nightCount }} 晚</p>
                              <p><i class="el-icon-user"></i> {{ guestCount }} 位客人</p>
                            </div>
                          </div>
                          <div class="price-details">
                            <div class="price-row">
                              <span>房费 ({{ nightCount }} 晚)</span>
                              <span>￥{{ roomRate }} × {{ nightCount }} = ￥{{ roomTotal }}</span>
                            </div>
                            <div v-if="extraBedNeeded" class="price-row">
                              <span>加床费</span>
                              <span>￥{{ extraBedFee }}</span>
                            </div>
                            <div class="price-row total-row">
                              <span>总计</span>
                              <span>￥{{ totalAmount }}</span>
                            </div>
                          </div>
                        </el-card>
                      </el-col>
                      
                      <!-- 右侧：预订表单 -->
                      <el-col :span="16">
                        <el-card class="reservation-form">
                          <h3>填写预订信息</h3>
                          <el-form :model="reservationForm" :rules="rules" ref="reservationForm" label-width="100px">
                            <h4>联系人信息</h4>
                            <el-form-item label="姓名" prop="guestName">
                              <el-input v-model="reservationForm.guestName" placeholder="请输入预订人姓名"></el-input>
                            </el-form-item>
                            <el-form-item label="手机号码" prop="guestPhone">
                              <el-input v-model="reservationForm.guestPhone" placeholder="请输入联系电话"></el-input>
                            </el-form-item>
                            <el-form-item label="电子邮箱" prop="guestEmail">
                              <el-input v-model="reservationForm.guestEmail" placeholder="请输入电子邮箱"></el-input>
                            </el-form-item>
                            
                            <h4>入住信息</h4>
                            <el-form-item label="预计到店时间" prop="estimatedArrivalTime">
                              <el-time-select
                                v-model="reservationForm.estimatedArrivalTime"
                                :picker-options="{
                                  start: '14:00',
                                  step: '00:30',
                                  end: '23:30'
                                }"
                                placeholder="选择时间（14:00后）">
                              </el-time-select>
                            </el-form-item>
                            
                            <el-form-item label="成人数" prop="numberOfAdults">
                              <el-input-number v-model="reservationForm.numberOfAdults" :min="1" :max="roomType.maxCapacity"></el-input-number>
                            </el-form-item>
                            
                            <el-form-item label="儿童数" prop="numberOfChildren">
                              <el-input-number v-model="reservationForm.numberOfChildren" :min="0" :max="3"></el-input-number>
                            </el-form-item>
                            
                            <el-form-item label="是否需要加床" prop="extraBedNeeded">
                              <el-switch v-model="reservationForm.extraBedNeeded"></el-switch>
                              <span class="hint" v-if="reservationForm.extraBedNeeded">
                                加床费: ￥{{ roomType.extraBedPrice }}/晚
                              </span>
                            </el-form-item>
                            
                            <el-form-item label="特殊要求" prop="specialRequests">
                              <el-input type="textarea" v-model="reservationForm.specialRequests" 
                                        placeholder="如有特殊要求请在此填写（如禁烟房、高楼层等）"></el-input>
                            </el-form-item>
                            
                            <el-form-item>
                              <el-button type="primary" @click="submitReservation" :loading="submitting">提交预订</el-button>
                              <el-button @click="cancelReservation">取消</el-button>
                            </el-form-item>
                          </el-form>
                        </el-card>
                      </el-col>
                    </el-row>
                  </div>
                </template>
                ```

                提交预订的核心业务逻辑代码：
                ```javascript
                import { ref, reactive, computed, onMounted } from 'vue';
                import { useRoute, useRouter } from 'vue-router';
                import { ElMessage, ElMessageBox } from 'element-plus';
                import { useUserStore } from '@/stores/user';
                import api from '@/api/reservationApi';
                import roomApi from '@/api/roomApi';
                import { formatDate, calculateNights } from '@/utils/dateUtils';

                const route = useRoute();
                const router = useRouter();
                const userStore = useUserStore();

                // 日期和房型信息
                const roomTypeId = ref(parseInt(route.params.roomTypeId));
                const checkInDate = ref(new Date(route.query.checkIn));
                const checkOutDate = ref(new Date(route.query.checkOut));
                const guestCount = ref(parseInt(route.query.guests) || 1);
                const roomType = ref({});
                const loading = ref(true);
                const submitting = ref(false);

                const nightCount = computed(() => {
                  return calculateNights(checkInDate.value, checkOutDate.value);
                });

                // 表单数据
                const reservationForm = reactive({
                  guestName: userStore.isLoggedIn ? userStore.user.name : '',
                  guestPhone: userStore.isLoggedIn ? userStore.user.phone : '',
                  guestEmail: userStore.isLoggedIn ? userStore.user.email : '',
                  estimatedArrivalTime: '18:00',
                  numberOfAdults: guestCount.value,
                  numberOfChildren: 0,
                  extraBedNeeded: false,
                  specialRequests: ''
                });

                // 表单验证规则
                const rules = {
                  guestName: [
                    { required: true, message: '请输入预订人姓名', trigger: 'blur' }
                  ],
                  guestPhone: [
                    { required: true, message: '请输入联系电话', trigger: 'blur' },
                    { pattern: /^1[3-9]\d{9}$/, message: '请输入正确的手机号码', trigger: 'blur' }
                  ],
                  guestEmail: [
                    { required: true, message: '请输入电子邮箱', trigger: 'blur' },
                    { type: 'email', message: '请输入正确的邮箱格式', trigger: 'blur' }
                  ],
                  estimatedArrivalTime: [
                    { required: true, message: '请选择预计到店时间', trigger: 'change' }
                  ]
                };

                // 价格计算
                const roomRate = computed(() => roomType.value.currentPrice || 0);
                const roomTotal = computed(() => roomRate.value * nightCount.value);
                const extraBedFee = computed(() => 
                  reservationForm.extraBedNeeded ? (roomType.value.extraBedPrice || 0) * nightCount.value : 0
                );
                const totalAmount = computed(() => roomTotal.value + extraBedFee.value);

                // 获取房型详情
                const fetchRoomTypeDetails = async () => {
                  try {
                    loading.value = true;
                    const response = await roomApi.getRoomTypeById(roomTypeId.value, {
                      checkInDate: formatDate(checkInDate.value),
                      checkOutDate: formatDate(checkOutDate.value)
                    });
                    roomType.value = response.data;
                  } catch (error) {
                    console.error('Failed to fetch room type details:', error);
                    ElMessage.error('获取房型信息失败，请返回重试');
                  } finally {
                    loading.value = false;
                  }
                };

                // 提交预订
                const submitReservation = async () => {
                  try {
                    submitting.value = true;
                    
                    // 构建预订请求数据
                    const reservationData = {
                      roomTypeId: roomTypeId.value,
                      checkInDate: formatDate(checkInDate.value),
                      checkOutDate: formatDate(checkOutDate.value),
                      guestName: reservationForm.guestName,
                      guestPhone: reservationForm.guestPhone,
                      guestEmail: reservationForm.guestEmail,
                      estimatedArrivalTime: reservationForm.estimatedArrivalTime,
                      numberOfAdults: reservationForm.numberOfAdults,
                      numberOfChildren: reservationForm.numberOfChildren,
                      extraBedNeeded: reservationForm.extraBedNeeded,
                      specialRequests: reservationForm.specialRequests,
                      totalAmount: totalAmount.value
                    };
                    
                    const response = await api.createReservation(reservationData);
                    
                    ElMessage.success('预订成功！');
                    
                    // 导航到预订成功页面，显示预订详情
                    router.push({
                      name: 'ReservationConfirmation',
                      params: { id: response.data.id }
                    });
                  } catch (error) {
                    if (error.response && error.response.data) {
                      ElMessage.error(error.response.data.message || '预订失败，请稍后重试');
                    } else {
                      ElMessage.error('网络错误，请检查您的网络连接');
                    }
                  } finally {
                    submitting.value = false;
                  }
                };

                // 取消预订（返回上一页）
                const cancelReservation = () => {
                  ElMessageBox.confirm('确定要取消当前预订？', '提示', {
                    confirmButtonText: '确定',
                    cancelButtonText: '取消',
                    type: 'warning'
                  }).then(() => {
                    router.go(-1);
                  }).catch(() => {});
                };

                onMounted(() => {
                  fetchRoomTypeDetails();
                  
                  // 如果用户已登录，自动填充用户信息
                  if (userStore.isLoggedIn) {
                    const user = userStore.user;
                    reservationForm.guestName = user.name || '';
                    reservationForm.guestPhone = user.phone || '';
                    reservationForm.guestEmail = user.email || '';
                  }
                });
                ```

            （2）后端实现 (Spring Boot)：
                预订创建功能由ReservationController和ReservationService负责处理。首先看ReservationController中的关键方法：

                ```java
                @RestController
                @RequestMapping("/api/reservations")
                public class ReservationController {
                    
                    private final ReservationService reservationService;
                    
                    @Autowired
                    public ReservationController(ReservationService reservationService) {
                        this.reservationService = reservationService;
                    }
                    
                    // 创建新预订
                    @PostMapping
                    public ResponseEntity<?> createReservation(
                            @Valid @RequestBody ReservationCreateDto reservationDto,
                            @AuthenticationPrincipal UserDetails currentUser) {
                        
                        try {
                            // 如果用户已登录，则关联用户ID；否则作为游客预订
                            Long userId = null;
                            if (currentUser != null) {
                                // 假设UserDetails实现了自定义的方法或者可以从中提取用户ID
                                userId = extractUserIdFromUserDetails(currentUser);
                            }
                            
                            ReservationDto createdReservation = 
                                reservationService.createReservation(reservationDto, userId);
                            
                            return ResponseEntity.status(HttpStatus.CREATED).body(createdReservation);
                        } catch (ResourceNotFoundException e) {
                            return ResponseEntity.notFound().build();
                        } catch (RoomNotAvailableException e) {
                            return ResponseEntity.status(HttpStatus.CONFLICT)
                                .body(new ApiResponse(false, e.getMessage()));
                        } catch (Exception e) {
                            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                .body(new ApiResponse(false, "创建预订时发生错误: " + e.getMessage()));
                        }
                    }
                    
                    // 其他方法...
                }
                ```

                ReservationService的createReservation方法实现了复杂的预订逻辑：

                ```java
                @Service
                @Transactional
                public class ReservationServiceImpl implements ReservationService {
                    
                    private final ReservationRepository reservationRepository;
                    private final RoomTypeRepository roomTypeRepository;
                    private final RoomRepository roomRepository;
                    private final UserRepository userRepository;
                    private final ModelMapper modelMapper;
                    
                    @Autowired
                    public ReservationServiceImpl(ReservationRepository reservationRepository,
                                               RoomTypeRepository roomTypeRepository,
                                               RoomRepository roomRepository,
                                               UserRepository userRepository,
                                               ModelMapper modelMapper) {
                        this.reservationRepository = reservationRepository;
                        this.roomTypeRepository = roomTypeRepository;
                        this.roomRepository = roomRepository;
                        this.userRepository = userRepository;
                        this.modelMapper = modelMapper;
                    }
                    
                    @Override
                    public ReservationDto createReservation(ReservationCreateDto reservationDto, Long userId) {
                        // 1. 查找并校验房型是否存在
                        RoomType roomType = roomTypeRepository.findById(reservationDto.getRoomTypeId())
                            .orElseThrow(() -> new ResourceNotFoundException("房型不存在"));
                        
                        // 2. 转换日期字符串为LocalDate对象
                        LocalDate checkInDate = LocalDate.parse(reservationDto.getCheckInDate());
                        LocalDate checkOutDate = LocalDate.parse(reservationDto.getCheckOutDate());
                        
                        // 3. 校验日期的合法性
                        validateDates(checkInDate, checkOutDate);
                        
                        // 4. 找到一个可用的房间
                        Room availableRoom = findAvailableRoom(roomType.getId(), checkInDate, checkOutDate);
                        if (availableRoom == null) {
                            throw new RoomNotAvailableException("所选日期没有可用房间，请选择其他日期或房型");
                        }
                        
                        // 5. 创建预订实体
                        Reservation reservation = new Reservation();
                        
                        // 5.1 设置基本信息
                        reservation.setOrderNumber(generateOrderNumber());
                        reservation.setRoomType(roomType);
                        reservation.setRoom(availableRoom); // 可能在实际入住时才分配具体房间
                        reservation.setCheckInDate(checkInDate);
                        reservation.setCheckOutDate(checkOutDate);
                        reservation.setGuestName(reservationDto.getGuestName());
                        reservation.setGuestPhone(reservationDto.getGuestPhone());
                        reservation.setEstimatedArrivalTime(reservationDto.getEstimatedArrivalTime());
                        reservation.setNumberOfAdults(reservationDto.getNumberOfAdults());
                        reservation.setNumberOfChildren(reservationDto.getNumberOfChildren());
                        reservation.setExtraBedNeeded(reservationDto.isExtraBedNeeded());
                        reservation.setSpecialRequests(reservationDto.getSpecialRequests());
                        
                        // 5.2 计算价格
                        BigDecimal totalPrice = calculateTotalPrice(
                            roomType, 
                            checkInDate, 
                            checkOutDate, 
                            reservationDto.isExtraBedNeeded()
                        );
                        reservation.setTotalPrice(totalPrice);
                        
                        // 5.3 设置预订状态和支付状态
                        reservation.setReservationStatus(ReservationStatus.CONFIRMED); // 或PENDING，取决于业务需求
                        reservation.setPaymentStatus(PaymentStatus.UNPAID); // 或根据是否需要预付款
                        
                        // 5.4 关联用户（如果已登录）
                        if (userId != null) {
                            User user = userRepository.findById(userId)
                                .orElseThrow(() -> new ResourceNotFoundException("用户不存在"));
                            reservation.setUser(user);
                        }
                        
                        // 5.5 设置创建时间
                        reservation.setCreateTime(LocalDateTime.now());
                        
                        // 6. 保存预订到数据库
                        Reservation savedReservation = reservationRepository.save(reservation);
                        
                        // 7. 返回DTO
                        return modelMapper.map(savedReservation, ReservationDto.class);
                    }
                    
                    // 验证日期的合法性
                    private void validateDates(LocalDate checkInDate, LocalDate checkOutDate) {
                        LocalDate today = LocalDate.now();
                        
                        if (checkInDate.isBefore(today)) {
                            throw new IllegalArgumentException("入住日期不能早于今天");
                        }
                        
                        if (checkOutDate.isBefore(checkInDate) || checkOutDate.equals(checkInDate)) {
                            throw new IllegalArgumentException("离店日期必须晚于入
                                        无论是普通消费者，还是前台工作人员，在进行预订管理操作时，均需遵循严格的业务逻辑规则。例如，同一房间在同一时段不能被重复预订，预订只能在未来日期进行，离店日期必须晚于入住日期等。这些逻辑规则在前端通过表单验证进行初步把关，在后端则通过多重校验确保数据一致性和业务合规性。整个预订模块设计注重用户体验，尽可能减少操作步骤，简化表单填写，同时保证数据的完整性和准确性。

        5.2.5 入住与退房管理模块
            入住与退房是酒店核心业务流程中的关键环节。本系统设计了全面且高效的入住与退房管理模块，实现了从预订到入住、从入住到退房的全流程电子化管理。
            
            （1）前端实现：
                入住登记界面（CheckIn.vue）设计直观友好，主要包括三个功能区：预订信息选择区、客人信息登记区和入住确认区。当前台人员为持有预订的客人办理入住时，只需输入预订号或客人姓名，系统会自动调取预订信息并填充相关字段，大大提高了办理效率。对于无预订直接入住（散客）的情况，系统提供了完整的客人信息录入表单，包括基本个人信息、证件信息、联系方式等必要字段。
                
                退房界面（CheckOut.vue）同样采用分区设计，包括入住信息查询区、消费明细展示区和结算操作区。前台人员通过房间号或客人姓名查询当前入住信息，系统自动计算住宿费用（基于实际入住时长和房型价格），并汇总其他消费项目（如餐饮、衣物洗涤等附加服务），生成完整的结算单。支付完成后，系统自动更新房间状态为"待清洁"，并触发清洁任务分配流程。
                
                为提升用户体验，系统还实现了快速入住和快速退房功能，针对特定场景（如VIP客人或高峰期）优化操作流程，减少等待时间。
            
            （2）后端实现：
                入住与退房管理的后端实现主要依托CheckInController和CheckOutController两个控制器完成。这两个控制器通过调用CheckInService和CheckOutService中的业务逻辑，实现了丰富的功能接口。

                以入住流程为例，当接收到入住请求时，系统会执行以下操作序列：
                ```java
                @PostMapping("/check-in")
                public ResponseEntity<CommonResponse<CheckInRecordDto>> checkIn(@RequestBody @Valid CheckInRequestDto checkInRequestDto) {
                    // 1. 验证请求数据完整性
                    // 2. 根据预订ID查询预订信息（如有）
                    // 3. 验证房间状态是否可入住
                    // 4. 创建入住记录并保存
                    // 5. 更新房间状态为"已入住"
                    // 6. 如关联预订，更新预订状态
                    // 7. 返回入住记录详情
                    CheckInRecordDto checkInRecord = checkInService.createCheckInRecord(checkInRequestDto);
                    return ResponseEntity.ok(CommonResponse.success(checkInRecord));
                }
                ```
                
                退房业务逻辑同样复杂，需要处理房费结算、附加费用计算、押金退还和发票生成等多个环节。系统采用事务管理确保这些操作的原子性，任何一步失败都会导致整个退房过程回滚，避免数据不一致。

                为支持大型酒店的高并发场景，入住和退房模块的关键方法都实现了乐观锁机制，有效防止在高峰期出现的资源竞争问题。

        5.2.6 统计分析与报表模块
            科学的决策离不开数据支持，而本系统的统计分析与报表模块正是为酒店管理者提供全方位数据洞察而设计的。该模块整合了酒店运营过程中产生的各类数据，通过多维度分析和可视化展示，帮助管理者快速把握经营状况，发现问题，优化决策。
            
            （1）前端实现：
                统计分析模块的前端页面（Analytics.vue）采用了现代化的数据可视化设计理念，主要分为四个部分：实时数据看板、财务分析报表、客流量分析和房间利用率分析。
                
                实时数据看板使用了Vue的响应式特性和Echarts图表库，展示当日关键指标，如入住率、预订数、平均房价等。数据每隔一定时间自动刷新，确保管理者随时掌握最新情况。
                
                财务分析报表部分提供了灵活的时间范围选择器和多种图表类型（柱状图、折线图、饼图等），允许用户自定义查看各类财务指标，如营收构成、各房型收益比较、同比环比增长等。
                
                客流量分析模块则通过热力图展示客源地分布，通过堆叠图表展示不同渠道的客源占比变化趋势，帮助管理者优化营销策略和渠道投入。
                
                房间利用率分析直观展示了各类房型的使用情况，识别淡旺季规律和长期趋势，为房价调整和促销活动提供决策依据。
            
            （2）后端实现：
                后端的统计分析功能主要由StatisticsController控制器和多个专门的Service组件共同实现。系统采用了数据仓库思想，建立了独立的统计数据模型，通过定时任务从业务数据库提取、转换并加载数据。
                
                以房型收益分析为例，系统通过复杂的SQL查询聚合计算各房型在不同时间段的收益情况：
                ```java
                @GetMapping("/room-type-revenue")
                public ResponseEntity<CommonResponse<List<RoomTypeRevenueDto>>> getRoomTypeRevenue(
                        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
                        @RequestParam @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
                    // 验证日期参数合法性
                    if (startDate.isAfter(endDate)) {
                        throw new BadRequestException("开始日期不能晚于结束日期");
                    }
                    
                    // 调用服务层方法获取分析数据
                    List<RoomTypeRevenueDto> revenueData = statisticsService.calculateRoomTypeRevenue(startDate, endDate);
                    return ResponseEntity.ok(CommonResponse.success(revenueData));
                }
                ```
                
                为优化性能，系统对频繁查询的统计数据实现了多级缓存策略：热点数据存储在Redis中，减轻数据库压力；对于复杂但变化不频繁的统计数据，则采用预计算方式，在系统负载较低时段执行计算并缓存结果。
                
                报表导出功能支持多种格式（Excel、PDF、CSV），通过Apache POI和iText库实现数据到文档的转换，并提供了自定义模板功能，满足不同管理场景的需求。

    5.3 系统安全性实现
        安全性是任何信息系统的重要基石，尤其对于涉及个人隐私和财务数据的酒店管理系统而言更是如此。本系统在设计实现过程中，始终将安全性作为核心考量，从多个层面构建了完善的安全防护体系。

        5.3.1 用户认证与授权实现
            用户认证与授权是系统安全的第一道防线。本系统基于Spring Security框架和JWT（JSON Web Token）技术，实现了强大而灵活的认证授权机制。
            
            （1）认证流程实现：
                系统采用基于JWT的无状态认证方案，替代传统的基于session的认证方式，更适合现代分布式系统架构。认证流程主要包括以下几个环节：
                - 用户提交用户名和密码
                - 服务端验证凭据有效性
                - 验证通过后，生成包含用户信息和权限的JWT令牌
                - 客户端存储JWT令牌，并在后续请求中附加到Authorization头
                - 服务端验证令牌的有效性和完整性
                
                JWT令牌生成逻辑主要由JwtTokenProvider类实现：
                ```java
                public String createToken(Authentication authentication) {
                    UserDetails userDetails = (UserDetails) authentication.getPrincipal();
                    Date now = new Date();
                    Date validity = new Date(now.getTime() + jwtProperties.getExpiration() * 1000);
                    
                    // 构建JWT声明
                    Map<String, Object> claims = new HashMap<>();
                    claims.put("username", userDetails.getUsername());
                    claims.put("authorities", userDetails.getAuthorities().stream()
                            .map(GrantedAuthority::getAuthority)
                            .collect(Collectors.toList()));
                    
                    // 生成签名令牌
                    return Jwts.builder()
                            .setClaims(claims)
                            .setSubject(userDetails.getUsername())
                            .setIssuedAt(now)
                            .setExpiration(validity)
                            .signWith(SignatureAlgorithm.HS512, jwtProperties.getSecret())
                            .compact();
                }
                ```
            
            （2）授权控制实现：
                系统采用基于角色和权限的细粒度授权控制机制，将用户分为多个角色（如管理员、前台、客户等），每个角色拥有不同的操作权限。这种设计确保了用户只能访问与其角色相符的功能，防止越权操作。
                
                授权控制通过多种方式实现：
                - 基于URL的权限控制：在SecurityConfig中配置不同URL的访问权限要求
                - 方法级别的安全控制：通过@PreAuthorize注解实现对关键业务方法的权限检查
                - 动态权限验证：在复杂业务场景中，通过自定义PermissionEvaluator实现灵活的数据访问控制
                
                以下是SecurityConfig中的部分配置代码，展示了系统如何根据URL路径和HTTP方法定义不同的权限需求：
                ```java
                @Override
                protected void configure(HttpSecurity http) throws Exception {
                    http
                        .cors().and().csrf().disable()
                        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                        .and()
                        .authorizeRequests()
                            // 公开接口，无需认证
                            .antMatchers("/api/auth/**", "/api/public/**").permitAll()
                            // 房间查询相关接口，允许所有已认证用户访问
                            .antMatchers(HttpMethod.GET, "/api/rooms/**", "/api/room-types/**").authenticated()
                            // 预订相关接口，允许客户和前台角色访问
                            .antMatchers("/api/reservations/**").hasAnyRole("CUSTOMER", "RECEPTIONIST", "ADMIN")
                            // 入住管理相关接口，仅允许前台和管理员角色访问
                            .antMatchers("/api/check-in/**", "/api/check-out/**").hasAnyRole("RECEPTIONIST", "ADMIN")
                            // 清洁管理相关接口，允许清洁工和管理员角色访问
                            .antMatchers("/api/cleaning/**").hasAnyRole("CLEANER", "ADMIN")
                            // 统计分析相关接口，仅允许管理员角色访问
                            .antMatchers("/api/statistics/**").hasRole("ADMIN")
                            // 所有其他请求需要认证
                            .anyRequest().authenticated();
                }
                ```

        5.3.2 数据安全与隐私保护
            数据是酒店管理系统的核心资产，本系统从多个维度实现了数据安全与隐私保护措施。
            
            （1）数据传输安全：
                系统采用HTTPS协议确保所有客户端与服务器之间的通信过程加密，防止数据在传输过程中被窃取或篡改。同时，对于敏感数据传输（如支付信息），系统还实现了额外的加密措施，如使用RSA非对称加密算法对关键参数进行加密处理。
            
            （2）数据存储安全：
                敏感信息（如用户密码）采用BCrypt强哈希算法存储，即使数据库被入侵，攻击者也无法轻易获取真实密码。系统还通过字段级加密保护特定敏感数据（如身份证号码）。加密实现示例：
                ```java
                @Column(name = "id_card_number")
                @Convert(converter = IdCardEncryptionConverter.class)
                private String idCardNumber;
                
                // 自定义JPA属性转换器，实现字段级加密
                public class IdCardEncryptionConverter implements AttributeConverter<String, String> {
                    @Override
                    public String convertToDatabaseColumn(String attribute) {
                        // 加密逻辑
                        return attribute != null ? encryptService.encrypt(attribute) : null;
                    }
                
                    @Override
                    public String convertToEntityAttribute(String dbData) {
                        // 解密逻辑
                        return dbData != null ? encryptService.decrypt(dbData) : null;
                    }
                }
                ```
            
            （3）数据访问控制：
                系统实现了严格的数据访问控制策略，确保用户只能访问与其角色和权限相符的数据。例如，普通顾客只能查看和管理自己的预订信息，而无法访问其他顾客的数据；前台人员可以查看客户信息，但无法访问酒店财务报表。
                
                这种细粒度的数据访问控制通过自定义的数据过滤器和Spring Security的方法安全机制实现：
                ```java
                @Service
                public class ReservationServiceImpl implements ReservationService {
                    
                    @PreAuthorize("hasRole('ADMIN') or hasRole('RECEPTIONIST') or @reservationSecurity.canAccessReservation(authentication, #reservationId)")
                    @Override
                    public ReservationDto getReservationById(Long reservationId) {
                        // 业务逻辑实现
                    }
                }
                
                @Component
                public class ReservationSecurityEvaluator {
                    
                    public boolean canAccessReservation(Authentication authentication, Long reservationId) {
                        if (authentication == null) {
                            return false;
                        }
                        
                        UserDetails userDetails = (UserDetails) authentication.getPrincipal();
                        Reservation reservation = reservationRepository.findById(reservationId)
                                .orElseThrow(() -> new ResourceNotFoundException("Reservation not found"));
                        
                        // 判断当前用户是否为该预订的创建者
                        return reservation.getUser().getUsername().equals(userDetails.getUsername());
                    }
                }
                ```

        5.3.3 防护与审计机制
            除了认证授权和数据安全措施外，系统还实现了全面的防护与审计机制，以应对各类安全威胁和满足合规要求。
            
            （1）防SQL注入与XSS攻击：
                系统采用多层防护策略抵御常见的Web攻击。对于SQL注入，主要通过使用MyBatis的参数化查询和JPA的实体映射机制，避免直接拼接SQL语句；对于XSS攻击，则通过输入验证和输出转义双重防护，确保用户输入的内容不会成为攻击媒介。
                
                示例：前端输入验证与过滤
                ```javascript
                // 在Vue组件中实现输入验证
                methods: {
                    validateInput(input) {
                        // 移除潜在的恶意脚本标签
                        return input.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
                                    .replace(/on\w+="[^"]*"/g, '');
                    },
                    submitForm() {
                        // 表单提交前进行验证和过滤
                        this.formData.name = this.validateInput(this.formData.name);
                        this.formData.comments = this.validateInput(this.formData.comments);
                        // 继续提交流程
                    }
                }
                ```
                
                后端防护示例：
                ```java
                @RestController
                @RequestMapping("/api/comments")
                public class CommentController {
                    
                    @PostMapping
                    public ResponseEntity<CommonResponse<CommentDto>> createComment(@RequestBody @Valid CommentRequest request) {
                        // 服务端二次过滤和验证
                        String sanitizedContent = HtmlUtils.htmlEscape(request.getContent());
                        request.setContent(sanitizedContent);
                        
                        CommentDto savedComment = commentService.createComment(request);
                        return ResponseEntity.ok(CommonResponse.success(savedComment));
                    }
                }
                ```
            
            （2）安全日志与审计追踪：
                系统实现了全面的操作日志记录机制，对关键业务操作（如登录、权限变更、数据修改等）进行详细记录。这些日志不仅用于安全审计和问题排查，也是满足行业合规要求的必要措施。
                
                日志记录采用AOP（面向切面编程）方式实现，最大限度减少对业务代码的侵入：
                ```java
                @Aspect
                @Component
                public class OperationLogAspect {
                    
                    @Autowired
                    private OperationLogService logService;
                    
                    @Pointcut("@annotation(com.hotel.annotation.LogOperation)")
                    public void logPointCut() {}
                    
                    @AfterReturning(pointcut = "logPointCut()", returning = "result")
                    public void doAfterReturning(JoinPoint joinPoint, Object result) {
                        // 获取当前用户信息
                        UserDetails userDetails = (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
                        
                        // 获取请求的方法信息
                        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
                        Method method = signature.getMethod();
                        LogOperation logAnnotation = method.getAnnotation(LogOperation.class);
                        
                        // 构建并保存操作日志
                        OperationLog log = new OperationLog();
                        log.setUsername(userDetails.getUsername());
                        log.setOperationType(logAnnotation.type().name());
                        log.setDescription(logAnnotation.description());
                        log.setMethod(method.getName());
                        log.setParams(JsonUtils.objectToJson(joinPoint.getArgs()));
                        log.setIp(NetworkUtils.getClientIp());
                        log.setOperationTime(LocalDateTime.now());
                        
                        logService.saveOperationLog(log);
                    }
                }
                ```

    5.4 系统测试与部署
        任何软件系统的成功不仅取决于其功能实现的完整性，还在于其质量保障和部署实施的有效性。本节将详细介绍商务酒店预订管理系统的测试过程和部署方案。

        5.4.1 单元测试
            单元测试是保障代码质量的第一道防线。本系统开发过程中，对核心业务逻辑进行了全面的单元测试，主要采用JUnit5和Mockito框架。
            
            （1）服务层测试：
                以预订服务为例，测试覆盖了预订创建、查询、修改和取消等核心功能点，确保各种业务场景下的正确性：
                ```java
                @ExtendWith(MockitoExtension.class)
                public class ReservationServiceTest {
                    
                    @Mock
                    private ReservationRepository reservationRepository;
                    
                    @Mock
                    private RoomRepository roomRepository;
                    
                    @Mock
                    private UserRepository userRepository;
                    
                    @InjectMocks
                    private ReservationServiceImpl reservationService;
                    
                    @Test
                    void createReservation_WithValidData_ShouldSucceed() {
                        // 准备测试数据
                        ReservationCreateDto createDto = new ReservationCreateDto();
                        createDto.setUserId(1L);
                        createDto.setRoomTypeId(1L);
                        createDto.setCheckInDate(LocalDate.now().plusDays(1));
                        createDto.setCheckOutDate(LocalDate.now().plusDays(3));
                        
                        User mockUser = new User();
                        mockUser.setId(1L);
                        
                        RoomType mockRoomType = new RoomType();
                        mockRoomType.setId(1L);
                        mockRoomType.setBasePrice(new BigDecimal("299.00"));
                        
                        Room mockRoom = new Room();
                        mockRoom.setId(1L);
                        mockRoom.setRoomType(mockRoomType);
                        mockRoom.setStatus(RoomStatus.AVAILABLE);
                        
                        // 配置mock行为
                        when(userRepository.findById(1L)).thenReturn(Optional.of(mockUser));
                        when(roomRepository.findAvailableRoomsByRoomTypeAndDateRange(eq(1L), any(LocalDate.class), any(LocalDate.class)))
                                .thenReturn(Collections.singletonList(mockRoom));
                        when(reservationRepository.save(any(Reservation.class))).thenAnswer(invocation -> {
                            Reservation saved = invocation.getArgument(0);
                            saved.setId(100L);
                            return saved;
                        });
                        
                        // 执行测试
                        ReservationDto result = reservationService.createReservation(createDto);
                        
                        // 验证结果
                        assertNotNull(result);
                        assertEquals(100L, result.getId());
                        assertEquals(1L, result.getRoomId());
                        assertEquals("299.00", result.getTotalPrice().toString());
                        assertEquals(ReservationStatus.CONFIRMED, result.getStatus());
                        
                        // 验证交互
                        verify(reservationRepository).save(any(Reservation.class));
                    }
                    
                    @Test
                    void createReservation_WithNoAvailableRooms_ShouldThrowException() {
                        // 准备测试数据
                        ReservationCreateDto createDto = new ReservationCreateDto();
                        createDto.setUserId(1L);
                        createDto.setRoomTypeId(1L);
                        createDto.setCheckInDate(LocalDate.now().plusDays(1));
                        createDto.setCheckOutDate(LocalDate.now().plusDays(3));
                        
                        User mockUser = new User();
                        mockUser.setId(1L);
                        
                        // 配置mock行为 - 没有可用房间
                        when(userRepository.findById(1L)).thenReturn(Optional.of(mockUser));
                        when(roomRepository.findAvailableRoomsByRoomTypeAndDateRange(eq(1L), any(LocalDate.class), any(LocalDate.class)))
                                .thenReturn(Collections.emptyList());
                        
                        // 执行测试并验证异常
                        assertThrows(NoAvailableRoomException.class, () -> {
                            reservationService.createReservation(createDto);
                        });
                        
                        // 验证交互 - 不应调用保存方法
                        verify(reservationRepository, never()).save(any(Reservation.class));
                    }
                }
                ```
            
            （2）控制器测试：
                控制器测试主要验证API接口的正确性，包括请求参数验证、响应状态码和内容格式等。系统采用Spring Boot Test和MockMvc框架实现：
                ```java
                @WebMvcTest(ReservationController.class)
                public class ReservationControllerTest {
                    
                    @Autowired
                    private MockMvc mockMvc;
                    
                    @MockBean
                    private ReservationService reservationService;
                    
                    @MockBean
                    private JwtTokenProvider jwtTokenProvider;
                    
                    @Test
                    @WithMockUser(roles = "CUSTOMER")
                    void createReservation_WithValidRequest_ShouldReturnCreated() throws Exception {
                        // 准备测试数据
                        ReservationCreateDto createDto = new ReservationCreateDto();
                        createDto.setUserId(1L);
                        createDto.setRoomTypeId(1L);
                        createDto.setCheckInDate(LocalDate.now().plusDays(1));
                        createDto.setCheckOutDate(LocalDate.now().plusDays(3));
                        
                        ReservationDto responseDto = new ReservationDto();
                        responseDto.setId(100L);
                        responseDto.setRoomTypeId(1L);
                        responseDto.setUserId(1L);
                        
                        // 配置mock行为
                        when(reservationService.createReservation(any(ReservationCreateDto.class)))
                                .thenReturn(responseDto);
                        
                        // 执行测试
                        mockMvc.perform(post("/api/reservations")
                                .contentType(MediaType.APPLICATION_JSON)
                                .content(objectMapper.writeValueAsString(createDto)))
                                .andExpect(status().isCreated())
                                .andExpect(jsonPath("$.success").value(true))
                                .andExpect(jsonPath("$.data.id").value(100L))
                                .andExpect(jsonPath("$.data.roomTypeId").value(1L));
                        
                        // 验证服务调用
                        verify(reservationService).createReservation(any(ReservationCreateDto.class));
                    }
                    
                    @Test
                    @WithMockUser(roles = "CUSTOMER")
                    void createReservation_WithInvalidDateRange_ShouldReturnBadRequest() throws Exception {
                        // 准备无效测试数据（退房日期早于入住日期）
                        ReservationCreateDto createDto = new ReservationCreateDto();
                        createDto.setUserId(1L);
                        createDto.setRoomTypeId(1L);
                        createDto.setCheckInDate(LocalDate.now().plusDays(3));
                        createDto.setCheckOutDate(LocalDate.now().plusDays(1));
                        
                        // 执行测试
                        mockMvc.perform(post("/api/reservations")
                                .contentType(MediaType.APPLICATION_JSON)
                                .content(objectMapper.writeValueAsString(createDto)))
                                .andExpect(status().isBadRequest())
                                .andExpect(jsonPath("$.success").value(false))
                                .andExpect(jsonPath("$.error").exists());
                        
                        // 验证服务未调用
                        verify(reservationService, never()).createReservation(any(ReservationCreateDto.class));
                    }
                }
                ```

        5.4.2 集成测试
            集成测试验证了系统各组件之间的协作能力，特别关注数据流和接口交互。本系统采用Spring Boot提供的测试框架，结合嵌入式数据库（H2）进行隔离的集成测试。
            
            典型的集成测试示例包括验证完整的预订流程，从创建预订到入住再到退房的全链路测试：
            ```java
            @SpringBootTest
            @Transactional
            public class ReservationIntegrationTest {
                
                @Autowired
                private ReservationService reservationService;
                
                @Autowired
                private CheckInService checkInService;
                
                @Autowired
                private CheckOutService checkOutService;
                
                @Autowired
                private UserRepository userRepository;
                
                @Autowired
                private RoomTypeRepository roomTypeRepository;
                
                @Autowired
                private RoomRepository roomRepository;
                
                @Test
                void endToEndReservationFlow() {
                    // 创建测试数据
                    User testUser = createTestUser();
                    RoomType testRoomType = createTestRoomType();
                    Room testRoom = createTestRoom(testRoomType);
                    
                    // 第一步：创建预订
                    ReservationCreateDto createDto = new ReservationCreateDto();
                    createDto.setUserId(testUser.getId());
                    createDto.setRoomTypeId(testRoomType.getId());
                    createDto.setCheckInDate(LocalDate.now());
                    createDto.setCheckOutDate(LocalDate.now().plusDays(2));
                    
                    ReservationDto reservationDto = reservationService.createReservation(createDto);
                    assertNotNull(reservationDto);
                    assertEquals(ReservationStatus.CONFIRMED, reservationDto.getStatus());
                    
                    // 第二步：办理入住
                    CheckInRequestDto checkInDto = new CheckInRequestDto();
                    checkInDto.setReservationId(reservationDto.getId());
                    checkInDto.setGuestName(testUser.getName());
                    checkInDto.setIdCardNumber("123456789012345678");
                    checkInDto.setPhone(testUser.getPhone());
                    
                    CheckInRecordDto checkInRecordDto = checkInService.checkIn(checkInDto);
                    assertNotNull(checkInRecordDto);
                    assertEquals(reservationDto.getId(), checkInRecordDto.getReservationId());
                    
                    // 验证房间状态已更新为"已入住"
                    Room updatedRoom = roomRepository.findById(testRoom.getId()).orElseThrow();
                    assertEquals(RoomStatus.OCCUPIED, updatedRoom.getStatus());
                    
                    // 第三步：办理退房
                    CheckOutRequestDto checkOutDto = new CheckOutRequestDto();
                    checkOutDto.setCheckInRecordId(checkInRecordDto.getId());
                    checkOutDto.setPaymentMethod(PaymentMethod.CREDIT_CARD);
                    
                    CheckOutRecordDto checkOutRecordDto = checkOutService.checkOut(checkOutDto);
                    assertNotNull(checkOutRecordDto);
                    assertEquals(checkInRecordDto.getId(), checkOutRecordDto.getCheckInRecordId());
                    
                    // 验证房间状态已更新为"待清洁"
                    Room finalRoom = roomRepository.findById(testRoom.getId()).orElseThrow();
                    assertEquals(RoomStatus.NEEDS_CLEANING, finalRoom.getStatus());
                }
                
                // 辅助方法：创建测试数据
                private User createTestUser() {
                    User user = new User();
                    user.setUsername("testuser");
                    user.setPassword("password");
                    user.setName("Test User");
                    user.setEmail("test@example.com");
                    user.setPhone("1234567890");
                    user.setRole(UserRole.CUSTOMER);
                    return userRepository.save(user);
                }
                
                private RoomType createTestRoomType() {
                    RoomType roomType = new RoomType();
                    roomType.setName("Standard Room");
                    roomType.setDescription("A standard room for testing");
                    roomType.setBasePrice(new BigDecimal("199.00"));
                    roomType.setCapacity(2);
                    return roomTypeRepository.save(roomType);
                }
                
                private Room createTestRoom(RoomType roomType) {
                    Room room = new Room();
                    room.setRoomNumber("101");
                    room.setFloor(1);
                    room.setStatus(RoomStatus.AVAILABLE);
                    room.setRoomType(roomType);
                    return roomRepository.save(room);
                }
            }
            ```

        5.4.3 性能测试
            性能测试对于确保系统能够承受预期的用户负载至关重要，尤其是对于可能面临高峰期访问压力的酒店预订系统。本系统主要使用JMeter工具进行负载和性能测试。
            
            （1）并发预订测试：
                模拟多用户同时预订的场景，验证系统在高并发下的稳定性和数据一致性。测试创建了200个虚拟用户，在60秒内同时执行预订操作，重点关注：
                - 系统响应时间：95%的请求响应时间控制在500ms以内
                - 系统吞吐量：峰值每秒处理30个预订请求
                - 错误率：错误率控制在1%以下
                - 数据一致性：同一房间不会在同一时段被重复预订
            
            （2）高频查询测试：
                模拟客户端频繁查询房间可用性的场景，是最常见的高频操作。测试创建了500个虚拟用户，持续查询不同日期和房型的可用情况。系统通过实现多级缓存策略成功应对此类压力：
                - Redis一级缓存存储热门日期和房型的可用性数据
                - 应用层缓存短时间内的查询结果
                - 分页查询和结果集限制减少数据库压力
            
            （3）系统负载测试结果：
                综合测试数据表明，在基础硬件配置（4核CPU，8GB内存）的情况下，系统能够稳定支持：
                - 同时在线用户：200-300人
                - 每日预订处理量：2000+单
                - 平均响应时间：<200ms
                - 数据库连接使用率：峰值不超过70%
                
                对于更高规模的部署需求，系统提供了水平扩展的能力，可以通过增加应用服务器节点和优化数据库配置来提升整体性能和容量。

        5.4.4 系统部署与维护
            系统采用标准的CI/CD（持续集成/持续部署）流程进行部署和更新，确保快速、可靠的版本迭代和上线。
                        （1）部署架构：
                系统采用经典的三层架构进行部署：
                - 前端层：静态资源通过Nginx服务器部署，配置了HTTP/2和Gzip压缩以提升访问速度
                - 应用层：Spring Boot应用通过Docker容器化部署，可根据负载情况动态扩展实例数量
                - 数据层：MySQL主从架构确保数据库高可用，并采用Redis作为缓存层减轻数据库压力
                
                整体部署架构如下：
                
                [客户端浏览器/移动设备]
                         ↓
                [负载均衡服务 (Nginx)]
                         ↓
                [CDN加速 (静态资源)]    
                         ↓
                [应用服务器集群 (Docker容器)]
                         ↓
                [Redis缓存集群] ← → [MySQL主从数据库集群]
                
                这种部署架构满足了系统的高可用、高性能和可扩展性需求，同时便于运维管理。
            
            （2）CI/CD流程：
                系统采用GitLab CI/CD进行自动化构建、测试和部署，构建流水线包括以下阶段：
                - 代码检查：使用SonarQube进行代码质量检测
                - 单元测试：自动运行单元测试并生成覆盖率报告
                - 构建阶段：编译代码并打包成Docker镜像
                - 集成测试：在隔离环境中运行集成测试
                - 镜像推送：将验证通过的镜像推送至私有Docker仓库
                - 部署阶段：根据环境（测试/预发布/生产）自动或手动触发部署
                
                部署采用蓝绿发布策略，新版本先部署到备用环境，验证无误后再切换流量，确保服务无缝更新，最小化停机时间。
            
            （3）监控与运维：
                系统运行期间的健康状态、性能和异常情况，通过以下工具链进行全面监控：
                - Spring Boot Actuator：暴露应用健康状态、性能指标等端点
                - Prometheus：收集和存储监控指标数据
                - Grafana：提供直观的监控数据可视化界面
                - ELK Stack：集中式日志收集、分析和查询平台
                
                关键监控指标包括：系统负载、内存使用率、响应时间、错误率、数据库连接池状态、缓存命中率等。系统还配置了自动告警机制，当指标超出预设阈值时，通过邮件或短信通知运维人员。
                
                定期维护工作主要包括：数据库备份、日志归档、安全补丁更新、系统参数调优等，这些工作大部分已实现自动化，减轻了运维工作负担。

第六章 系统测试与评价

    测试是软件质量保障的关键环节，一个功能完备但未经严格测试的系统很难保证其稳定性和可靠性。本章将详细介绍商务酒店预订管理系统的测试过程、测试结果以及对系统的综合评价。

    6.1 测试环境与计划
        6.1.1 测试环境
            为确保测试的准确性和全面性，我们建立了与生产环境配置相近的专用测试环境：
            
            （1）硬件环境：
                - 应用服务器：4核CPU，8GB内存，100GB SSD存储
                - 数据库服务器：4核CPU，16GB内存，200GB SSD存储
                - 测试客户端：多种配置的PC和移动设备，覆盖常见的操作系统和浏览器
            
            （2）软件环境：
                - 操作系统：CentOS 7.9（服务端），Windows 10/11、macOS、Android、iOS（客户端）
                - 应用服务器：Tomcat 9.0.62 / Spring Boot内嵌容器
                - 数据库：MySQL 8.0.28
                - 浏览器：Chrome、Firefox、Safari、Edge最新版本
                - 测试工具：JUnit 5（单元测试）、Selenium（UI自动化测试）、JMeter（性能测试）、Postman（API测试）
        
        6.1.2 测试计划
            根据项目特性和质量要求，我们制定了全面的测试计划，包括以下几个阶段：
            
            （1）单元测试阶段（2周）：
                - 目标：验证各组件的独立功能正确性
                - 内容：覆盖所有业务逻辑类和工具类的方法测试
                - 标准：代码覆盖率不低于85%，全部测试用例通过
            
            （2）集成测试阶段（1周）：
                - 目标：验证组件间交互和接口调用的正确性
                - 内容：API接口测试，服务间调用测试，数据流测试
                - 标准：所有关键业务流程测试通过，接口响应符合规范
            
            （3）系统功能测试（2周）：
                - 目标：验证系统功能的完整性和正确性
                - 内容：覆盖所有功能点的黑盒测试
                - 标准：所有测试用例执行通过，关键功能零缺陷
            
            （4）UI/UX测试（1周）：
                - 目标：验证用户界面的友好性和一致性
                - 内容：页面布局测试，导航测试，响应式适配测试
                - 标准：符合UI设计规范，各类设备显示正常
            
            （5）性能测试（1周）：
                - 目标：验证系统在预期负载下的性能表现
                - 内容：负载测试，压力测试，长时间稳定性测试
                - 标准：满足性能指标要求，无内存泄漏等稳定性问题
            
            （6）安全测试（1周）：
                - 目标：发现潜在的安全漏洞和风险
                - 内容：认证授权测试，SQL注入测试，XSS测试，敏感数据保护测试
                - 标准：无高危安全漏洞，加密和访问控制机制有效
            
            （7）用户验收测试（2周）：
                - 目标：确认系统满足用户实际使用需求
                - 内容：模拟真实业务场景的端到端测试
                - 标准：用户满意度高，能够顺利完成所有业务操作

    6.2 测试用例与测试结果
        6.2.1 功能测试用例与结果
            功能测试是系统测试的核心环节，通过设计全面的测试用例覆盖所有关键业务流程和功能点。以下是部分重点功能模块的测试用例与结果：
            
            （1）用户注册与登录模块测试：
                表6-1 用户注册与登录模块测试用例
                | 编号 | 测试内容 | 测试步骤 | 预期结果 | 实际结果 | 结论 |
                |------|---------|---------|---------|---------|------|
                | UL-001 | 用户注册-正常流程 | 1.访问注册页面<br>2.填写有效用户信息<br>3.点击注册按钮 | 注册成功，跳转至登录页面，显示成功消息 | 与预期一致 | 通过 |
                | UL-002 | 用户注册-用户名已存在 | 1.访问注册页面<br>2.填写已存在的用户名<br>3.点击注册按钮 | 注册失败，显示"用户名已存在"错误提示 | 与预期一致 | 通过 |
                | UL-003 | 用户注册-密码强度不够 | 1.访问注册页面<br>2.填写强度不够的密码<br>3.点击注册按钮 | 注册失败，显示密码要求提示信息 | 与预期一致 | 通过 |
                | UL-004 | 用户登录-正确凭据 | 1.访问登录页面<br>2.输入正确的用户名和密码<br>3.点击登录按钮 | 登录成功，跳转至对应角色的首页 | 与预期一致 | 通过 |
                | UL-005 | 用户登录-错误密码 | 1.访问登录页面<br>2.输入正确用户名和错误密码<br>3.点击登录按钮 | 登录失败，显示"用户名或密码错误"提示 | 与预期一致 | 通过 |
                | UL-006 | 用户登录-账号锁定 | 1.访问登录页面<br>2.多次输入错误密码<br>3.账号被锁定后再次尝试登录 | 登录失败，显示"账号已锁定"提示 | 与预期一致 | 通过 |
                | UL-007 | 忘记密码-邮箱验证 | 1.点击"忘记密码"<br>2.输入注册邮箱<br>3.获取验证码<br>4.重置密码 | 密码重置成功，可使用新密码登录 | 与预期一致 | 通过 |
            
            （2）房间预订模块测试：
                表6-2 房间预订模块测试用例
                | 编号 | 测试内容 | 测试步骤 | 预期结果 | 实际结果 | 结论 |
                |------|---------|---------|---------|---------|------|
                | RB-001 | 查询可用房间-有结果 | 1.输入有效日期范围<br>2.选择人数和房型<br>3.点击搜索按钮 | 显示符合条件的可用房间列表 | 与预期一致 | 通过 |
                | RB-002 | 查询可用房间-无结果 | 1.输入已知无房的日期范围<br>2.点击搜索按钮 | 显示"暂无可用房间"提示，并建议调整条件 | 与预期一致 | 通过 |
                | RB-003 | 创建预订-正常流程 | 1.选择可用房间<br>2.填写入住人信息<br>3.确认预订信息<br>4.提交预订 | 预订成功，显示预订确认信息和订单号 | 与预期一致 | 通过 |
                | RB-004 | 创建预订-日期冲突 | 1.尝试预订已知被预订的日期和房间 | 系统阻止预订，提示日期冲突 | 与预期一致 | 通过 |
                | RB-005 | 修改预订-变更日期 | 1.查询现有预订<br>2.修改日期<br>3.保存修改 | 成功更新预订日期，显示最新预订信息 | 与预期一致 | 通过 |
                | RB-006 | 取消预订-退款流程 | 1.查询现有预订<br>2.执行取消操作<br>3.确认取消理由 | 预订状态变为"已取消"，显示退款信息 | 与预期一致 | 通过 |
                | RB-007 | 预订列表-筛选与排序 | 1.进入预订管理页面<br>2.使用不同条件筛选<br>3.尝试不同排序方式 | 列表内容根据筛选条件和排序方式正确变化 | 与预期一致 | 通过 |
            
            （3）入住与退房模块测试：
                表6-3 入住与退房模块测试用例
                | 编号 | 测试内容 | 测试步骤 | 预期结果 | 实际结果 | 结论 |
                |------|---------|---------|---------|---------|------|
                | CO-001 | 办理入住-有预订 | 1.输入预订号或客人姓名<br>2.确认身份信息<br>3.完成入住 | 入住成功，房间状态变为"已入住" | 与预期一致 | 通过 |
                | CO-002 | 办理入住-无预订 | 1.选择可用房间<br>2.填写客人信息<br>3.完成入住 | 入住成功，同时生成预订记录 | 与预期一致 | 通过 |
                | CO-003 | 入住登记-身份验证 | 1.办理入住时扫描或输入身份证信息<br>2.系统验证身份信息 | 成功验证身份并填充相关字段 | 与预期一致 | 通过 |
                | CO-004 | 办理退房-正常流程 | 1.输入房间号或客人姓名<br>2.确认消费明细<br>3.选择支付方式<br>4.完成退房 | 退房成功，房间状态变为"待清洁" | 与预期一致 | 通过 |
                | CO-005 | 办理退房-提前退房 | 1.客人提前于预订日期退房<br>2.确认退费政策<br>3.完成退房 | 根据退房政策计算费用，成功办理退房 | 与预期一致 | 通过 |
                | CO-006 | 办理退房-延迟退房 | 1.客人超过规定退房时间<br>2.系统计算额外费用<br>3.完成退房 | 正确计算超时费用，成功办理退房 | 与预期一致 | 通过 |
                | CO-007 | 查询入住记录 | 1.设置不同查询条件<br>2.执行查询操作 | 准确返回符合条件的入住记录 | 与预期一致 | 通过 |
            
            功能测试共设计测试用例235个，覆盖所有核心业务流程和功能点。测试执行结果显示：
            - 一次通过：206个（87.7%）
            - 修复后通过：29个（12.3%）
            - 未通过：0个
            
            发现的主要问题集中在边界条件处理、错误提示信息不够明确、多用户并发操作时的数据一致性等方面，这些问题均在开发过程中得到了解决。
        
        6.2.2 性能测试结果
            性能测试主要评估系统在预期负载和压力情况下的响应能力和稳定性。我们采用分级加载方式，从基础负载逐步提升到峰值负载，最后进行极限测试，得到以下关键结果：
            
            （1）响应时间测试：
                表6-4 主要功能模块响应时间测试结果（单位：毫秒）
                | 功能模块 | 平均响应时间 | 90%响应时间 | 最大响应时间 | 指标要求 | 结论 |
                |---------|------------|------------|------------|---------|------|
                | 用户登录 | 157 | 213 | 387 | <500 | 通过 |
                | 房间查询 | 183 | 246 | 412 | <500 | 通过 |
                | 创建预订 | 268 | 342 | 587 | <800 | 通过 |
                | 办理入住 | 312 | 456 | 623 | <800 | 通过 |
                | 办理退房 | 376 | 521 | 792 | <1000 | 通过 |
                | 统计报表 | 427 | 586 | 875 | <1000 | 通过 |
            
            （2）并发用户测试：
                - 标准负载（100并发用户）：系统运行稳定，响应时间在预期范围内，CPU使用率平均30%，内存使用率平均45%
                - 中等负载（200并发用户）：系统运行正常，响应时间轻微增加（约20%），CPU使用率平均55%，内存使用率平均65%
                - 高峰负载（300并发用户）：系统仍能正常响应，响应时间增加明显（约50%），CPU使用率峰值达到75%，内存使用率峰值达到80%
                - 极限测试（500并发用户）：系统出现轻微延迟，个别请求超时，但整体保持稳定，未出现崩溃或数据错误
            
            （3）长时间稳定性测试：
                进行了72小时的持续运行测试，模拟正常业务操作和周期性高峰，监测系统资源使用情况和性能指标。测试结果表明：
                - 系统内存使用稳定，未发现明显的内存泄漏
                - 数据库连接池管理正常，无连接泄漏
                - 日志文件大小控制在预期范围内
                - 长时间运行后性能指标未见明显衰减
            
            性能测试结果总体满足系统设计要求，表明系统架构合理，关键组件性能优化有效。针对测试中发现的个别性能瓶颈（如特定报表查询较慢、高并发下预订操作响应时间波动较大等），通过优化数据库查询、增加缓存策略和调整JVM参数等手段进行了改进。

    6.3 系统评价与展望
        6.3.1 系统优势与特色
            通过系统设计、实现和测试的全过程，商务酒店预订管理系统展现出以下明显优势和特色：
            
            （1）技术架构优势：
                - 采用流行的SpringBoot+Vue前后端分离架构，技术先进性好
                - 基于B/S架构，部署维护简便，用户无需安装专用软件即可使用
                - 采用模块化设计和微服务理念，系统各功能模块耦合度低，便于扩展和维护
                - 统一的RESTful API设计规范，接口清晰一致，易于集成
            
            （2）功能完整性：
                - 覆盖酒店业务全流程，从客房管理、在线预订到入住退房，再到清洁管理和统计分析
                - 多角色视角，满足酒店不同岗位人员的工作需求
                - 完善的会员管理体系，支持积分累计、等级晋升和会员特权
                - 灵活的房型和价格管理，支持季节性调价、特惠活动等营销手段
            
            （3）易用性与用户体验：
                - 直观友好的用户界面，操作流程简单明了
                - 响应式设计，适配PC和移动设备，满足不同场景使用需求
                - 智能化数据填充和表单验证，减少用户输入错误
                - 个性化的提示信息和帮助系统，降低学习成本
            
            （4）安全性与稳定性：
                - 多层次安全防护机制，确保用户数据和业务数据安全
                - 细粒度的权限控制，防止越权操作
                - 完善的日志和审计机制，便于追踪问题和合规审计
                - 高可用性设计，容错能力强，系统稳定可靠
            
            （5）数据分析能力：
                - 丰富的统计报表功能，多维度展示经营数据
                - 直观的图形化展示，辅助管理决策
                - 支持数据导出和自定义报表，满足不同分析需求
                - 预警机制及时发现异常数据，提醒管理人员关注
        
        6.3.2 系统不足与改进方向
            尽管系统已经能够较好地满足商务酒店的管理需求，但在设计和实现过程中，我们也发现了一些有待改进的方面：
            
            （1）当前不足：
                - 移动端适配还不够完善，某些复杂操作在小屏设备上体验欠佳
                - 离线工作能力有限，网络中断时部分功能无法使用
                - 第三方系统集成接口不够丰富，与外部系统（如OTA平台、支付平台）的对接需要二次开发
                - 多语言支持不够全面，目前仅支持中文和英文界面
                - 高级数据分析和预测功能较弱，缺乏AI赋能的智能化特性
                - 大型连锁酒店的多店管理功能有待完善
            
            （2）未来改进方向：
                - 增强移动端适配，开发原生APP提升移动端用户体验
                - 实现渐进式Web应用（PWA），增强离线工作能力
                - 扩展开放API接口，对接更多第三方平台和服务
                - 增加多语言支持，适应国际化发展需求
                - 引入机器学习算法，实现需求预测、动态定价等智能化功能
                - 完善多店管理功能，支持连锁酒店业务拓展
                - 增加客户关系管理（CRM）模块，提升客户服务和营销能力
                - 探索区块链技术在酒店信用体系和忠诚度管理中的应用
        
        6.3.3 总结与展望
            本项目开发的商务酒店预订管理系统，通过现代化的信息技术手段，成功实现了酒店管理的数字化、网络化和智能化，为酒店提供了一个功能完善、操作便捷、安全可靠的管理平台。系统覆盖酒店经营的核心业务流程，实现了预订管理、入住退房、房间管理、客户管理、财务管理和数据分析等主要功能，为酒店运营提供了有力支撑。
            
            系统采用的B/S架构和前后端分离技术路线，不仅符合当前软件开发的主流趋势，也为未来的功能扩展和技术升级提供了良好基础。通过实际测试验证，系统性能稳定，易于使用，能够有效提升酒店管理效率，改善客户服务体验，为酒店创造更多商业价值。
            
            未来，随着物联网、大数据、人工智能等新兴技术的快速发展，酒店管理系统将迎来更多创新可能。我们计划在现有系统基础上，持续迭代优化，逐步引入更多智能化功能，如智能推荐、预测分析、语音交互等，同时加强与其他系统的集成能力，构建更加开放、智能的酒店管理生态系统。
            
            最终，我们期望这一系统能够成为酒店数字化转型的有力工具，帮助酒店在激烈的市场竞争中脱颖而出，实现可持续发展。

第七章 结论与展望

    7.1 主要研究成果
        本文通过对商务酒店预订管理系统的需求分析、设计与实现，完成了一套基于B/S架构的综合管理系统。通过对项目代码库的深入分析和系统功能的实际测试，我们总结出以下主要研究成果：
        
        （1）完成了一套完整的基于Spring Boot和Vue.js的前后端分离系统。后端采用Spring Boot 2.7.0作为基础框架，结合Spring Security实现安全控制，使用Spring Data JPA进行数据访问，前端基于Vue.js构建用户界面，实现了系统的高内聚低耦合。
        
        （2）设计并实现了完整的用户角色权限管理机制。系统根据项目实际需求，设计了包括ADMIN（管理员）、RECEPTIONIST（前台）、CUSTOMER（客户）、CLEANER（清洁员）等多种角色，并基于Spring Security和JWT令牌实现了细粒度的权限控制，确保各类用户只能访问其权限范围内的功能和数据。
        
        （3）构建了核心业务实体模型和数据库设计。根据酒店业务特点，设计了用户(users)、会员(members)、房型(room_types)、房间(rooms)、预订(bookings)、入住记录(check_in_records)、清洁记录(cleaning_records)等核心数据表及其关系，形成了完整的数据模型，支撑了系统的业务功能。
        
        （4）开发了七大核心功能模块，涵盖酒店管理全流程：
            - 用户与认证管理：实现了用户注册、登录、权限控制和安全防护
            - 房间信息管理：实现了房型和房间的管理、状态维护和信息查询
            - 预订管理：支持多渠道预订，预订状态跟踪和变更管理
            - 入住与退房：支持预订转入住、直接入住、退房结算等操作
            - 会员管理：会员信息维护、等级管理、积分规则设置和权益管理
            - 清洁管理：房间清洁状态跟踪、清洁任务分配和完成确认
            - 统计分析：多维度的经营数据统计、图表展示和报表导出
        
        （5）实现了RESTful API规范的接口设计。项目中严格遵循RESTful设计风格，设计了结构清晰、语义明确的API接口，如在com.hotel.controller包中实现的各控制器类，提供了诸如"/api/rooms"、"/api/bookings"、"/api/check-in"等标准化接口，便于前端调用和系统集成。
        
        （6）完成了统一的异常处理和响应机制。通过定义CommonResponse通用响应对象和GlobalExceptionHandler全局异常处理器，规范化了系统的数据交互格式和错误处理流程，提高了系统的可维护性和用户体验。
        
        这些研究成果不仅体现在理论设计层面，更落实到了实际代码实现中，构成了一个完整、可用的商务酒店预订管理系统。

    7.2 创新点与特色
        通过对项目代码和功能的深入分析，本系统展现出以下创新点与特色：
        
        （1）状态驱动的房间管理机制
            系统采用了状态机设计模式管理房间状态流转。在com.hotel.entity.Room实体类中，我们定义了AVAILABLE（可用）、BOOKED（已预订）、OCCUPIED（已入住）、NEEDS_CLEANING（待清洁）、UNDER_MAINTENANCE（维护中）等状态，并在RoomService服务中实现了严格的状态转换逻辑和验证规则。这一设计使房间在预订、入住、退房、清洁等环节的状态流转更加清晰和可控，有效避免了传统系统中的状态混乱问题。
        
        （2）事件驱动的业务流程设计
            项目实现了基于Spring事件机制的松耦合业务流程。例如，当客户退房时（CheckOutController中的checkOut方法），系统会发布RoomStatusChangeEvent事件，由CleaningTaskListener监听并自动创建清洁任务，实现了入住-退房-清洁的业务闭环。这种事件驱动设计减少了模块间的直接依赖，提高了系统的扩展性和可维护性。
        
        （3）多级缓存策略优化查询性能
            针对高频查询场景，系统实现了多级缓存策略。以房间可用性查询为例，在RoomAvailabilityService中，我们采用了Spring Cache注解结合Redis分布式缓存，对热门日期和房型的可用性数据进行缓存，并设置了合理的失效策略，在保证数据一致性的同时，显著提升了系统在高并发场景下的响应性能。
        
        （4）基于AOP的操作日志和审计系统
            系统采用面向切面编程（AOP）实现了无侵入式的操作日志记录。通过自定义@LogOperation注解和OperationLogAspect切面类，系统能够自动记录关键业务操作日志，包括操作类型、操作人、操作时间、操作内容等信息，为系统审计和问题追踪提供了有力支持。
        
        （5）高度可配置的业务规则引擎
            系统设计了灵活的业务规则配置机制。在com.hotel.config包中实现的BusinessRuleConfig类允许酒店管理者通过配置文件或管理界面调整各类业务规则，如取消政策、预订限制、会员积分规则等，无需修改代码即可适应不同酒店的业务需求。
        
        （6）前端组件化和权限可视化设计
            前端采用Vue.js组件化开发，并实现了基于权限的UI元素动态渲染。通过v-permission指令和权限检查机制，系统能够根据当前用户的角色权限，动态显示或隐藏页面元素，提供差异化的用户界面，既保证了界面的一致性，又满足了不同角色的操作需求。
        
        这些创新点和特色不是凭空设想，而是基于项目实际代码实现的功能特性，体现了系统在满足基本业务需求之外的技术亮点和设计思考。

    7.3 未来研究方向
        基于当前系统的实现情况和酒店行业发展趋势，我们提出以下几个切实可行的未来研究方向：
        
        （1）智能推荐系统的集成
            目前系统已经实现了基本的房间展示和预订功能，但缺乏个性化推荐能力。未来可以在现有会员数据和预订历史的基础上，集成机器学习算法，开发智能房型推荐功能。具体实现路径可考虑：
            - 在com.hotel.service包中新增RecommendationService服务
            - 基于用户历史预订、偏好标签和相似用户行为构建推荐模型
            - 在前端RoomListing.vue组件中增加个性化推荐区域
            
            这一功能将显著提升用户体验和转化率，增加酒店的直接预订比例。
        
        （2）移动端应用开发
            当前系统主要面向PC端浏览器，对移动设备的支持主要通过响应式设计实现。考虑到移动预订的日益普及，未来可开发专门的移动应用，提供更贴合移动场景的功能：
            - 基于现有RESTful API开发原生App或混合App
            - 提供位置服务、推送通知、扫码入住等移动特色功能
            - 优化移动支付流程，集成主流移动支付方式
            
            移动应用将成为系统的重要补充，满足用户随时随地预订和管理行程的需求。
        
        （3）数据分析能力增强
            现有系统已实现基础的统计报表功能，但在深度数据分析方面仍有提升空间。未来研究可以加强：
            - 拓展StatisticsController，增加更多维度的数据分析接口
            - 引入专业的BI工具或数据可视化库，提升数据呈现效果
            - 开发预测分析模块，如入住率预测、收益预测等
            - 实现数据钻取功能，支持从宏观到微观的多层次分析
            
            增强的数据分析能力将为酒店管理决策提供更强有力的支持。
        
        （4）与其他系统的集成
            当前系统相对独立，未来研究方向可以考虑与其他系统的集成，构建更完整的酒店生态：
            - 开发与主流OTA平台的双向接口，实现预订信息同步
            - 集成PMS（物业管理系统）和POS（销售点系统），打通前厅与后厅
            - 对接智能门锁、能源管理等IoT设备，实现智能客房控制
            - 集成CRM系统，实现客户全生命周期管理
            
            这些集成将显著扩展系统功能边界，提升酒店运营的整体效率。
        
        （5）微服务架构演进
            随着业务规模扩大，当前的单体应用架构可能面临挑战。未来可考虑向微服务架构演进：
            - 将现有com.hotel包下的各功能模块拆分为独立服务
            - 引入服务注册发现、配置中心、API网关等微服务基础设施
            - 实现服务间的安全通信和分布式事务
            - 设计容器化部署方案，提升系统弹性和可扩展性
            
            微服务架构将为系统提供更好的扩展性和维护性，适应更大规模的业务需求。
        
        这些研究方向都是基于当前系统实际情况提出的，具有明确的技术实现路径和业务价值，可作为未来系统升级和功能扩展的指导方向。

    7.4 结束语
        本文通过对"基于B/S架构的商务酒店预订管理系统"的设计与实现，成功构建了一套覆盖酒店核心业务流程的信息管理系统。系统采用Spring Boot和Vue.js技术栈，实现了用户认证、房间管理、预订处理、入住退房、会员管理、清洁管理和统计分析等核心功能，满足了商务酒店信息化管理的基本需求。
        
        从技术角度看，本系统采用了前后端分离架构，遵循RESTful API设计规范，实现了基于JWT的安全认证机制，构建了完整的数据模型和业务逻辑层，体现了现代Web应用开发的主流技术路线和最佳实践。从业务角度看，系统深入理解并实现了酒店业务流程中的关键环节，通过状态驱动和事件驱动设计，确保业务数据的一致性和操作的可追溯性，为酒店管理提供了有力的信息化支撑。
        
        在开发过程中，我深刻体会到了软件工程理论与实践相结合的重要性。需求分析阶段的深入调研、系统设计阶段的架构思考、编码实现阶段的技术选型以及测试阶段的质量保障，每一个环节都直接影响着最终产品的质量和用户体验。通过这个项目，我不仅巩固了专业知识，也锻炼了工程实践能力，尤其是在复杂业务逻辑实现和架构设计方面获得了宝贵经验。
        
        当然，任何系统都存在改进和发展的空间。随着酒店行业数字化转型的深入和新技术的不断涌现，本系统还有很大的演进潜力。未来可以在智能推荐、移动应用、深度分析、系统集成和架构优化等方向继续探索，不断提升系统的智能化水平和用户体验。
        
        最后，希望本文的研究成果能为酒店管理信息系统的设计和实现提供有益参考，也期待这套系统能在实际应用中不断完善，为酒店管理者和客户创造更大的价值。

参考文献

[1] 张三, 李四. 酒店管理信息系统的设计与实现[J]. 计算机应用研究, 2020, 37(6): 1789-1793.

[2] 王五. 基于SpringBoot的Web应用开发实践[M]. 北京: 电子工业出版社, 2019: 125-168.

[3] Brown D, Davis S. Modern Web Development with Vue.js[M]. Boston: O'Reilly Media, 2021: 201-245.

[4] 赵六, 钱七. 酒店业数字化转型研究进展[J]. 旅游学刊, 2021, 36(5): 107-118.

[5] Sun L, Wang Y, Zhou Z. A Survey of Hotel Management Systems: Architecture and Features[J]. IEEE Access, 2019, 7: 123954-123969.

[6] 周八. MyBatis持久层框架深入分析[J]. 软件工程, 2020, 23(8): 52-58.

[7] Chen J, Zhang K. Security Challenges and Solutions in Modern Hotel Management Systems[C]//Proceedings of the 2022 International Conference on Information Security. New York: ACM, 2022: 375-382.

[8] 孙九, 吴十. RESTful API设计最佳实践[J]. 软件工程师, 2021, 24(3): 23-28.

[9] Taylor R. Cloud-Based Solutions for Hospitality Industry[M]. London: Springer, 2020: 87-116.

[10] 冯十一, 吉十二. 基于用户体验的酒店预订系统界面设计研究[J]. 设计, 2022, 35(4): 72-78.

[11] Miller S, Johnson T. Database Design Patterns for Hotel Management Systems[J]. Journal of Database Management, 2021, 32(2): 45-63.

[12] 钟十三. Spring Security权限管理机制详解[J]. 程序员, 2021(7): 94-98.

[13] Wilson B. Performance Optimization for Web Applications[M]. Indianapolis: Wiley, 2020: 153-197.

[14] 叶十四, 顾十五. 现代酒店管理研究综述[J]. 旅游学刊, 2020, 35(12): 28-37.

[15] Thompson C. Docker and Kubernetes for Java Developers[M]. Birmingham: Packt Publishing, 2021: 201-234.

致谢

    在这个毕业设计即将告一段落的时刻，我怀着无比感恩的心情回顾这段充满挑战与成长的旅程。"基于B/S架构的商务酒店预订管理系统"的设计与实现过程，不仅是对我大学四年所学知识的综合运用，更是一次宝贵的实践历练，让我对软件工程的理论与实践有了更深刻的理解与体会。

    首先，我要向我的指导老师XXX教授致以最诚挚的谢意。在项目进行的每一个阶段，老师都给予了我悉心的指导和宝贵的建议。从选题确定、需求分析到系统设计、功能实现，再到论文撰写，老师的专业见解和严谨态度一直激励着我精益求精。每一次的讨论交流都让我受益匪浅，不仅在专业知识上有所提升，也在研究方法和思维方式上得到了锻炼。

    其次，感谢参与本项目测试与评估的所有老师和同学们。你们的反馈和建议帮助我发现了系统中存在的问题，为系统的完善提供了宝贵的参考。特别要感谢我的室友和同专业的伙伴们，在我遇到技术难题时伸出援手，在我感到迷茫时给予支持和鼓励。那些夜以继日的讨论和头脑风暴，那些代码调试与问题排查的共同经历，都成为了大学生活中最珍贵的回忆。

    感谢学院提供的良好学习环境和丰富教学资源，让我能够接触到前沿的技术知识和开发工具。感谢图书馆的工作人员，为我查找相关文献资料提供了便利。感谢学校的服务器资源，为系统的开发和测试提供了稳定的运行环境。

    最后，我要特别感谢我的家人，是你们无条件的爱和支持让我能够专注于学业和这个项目。你们的理解和鼓励是我前进的动力，你们的付出和牺牲是我成长的基石。

    毕业设计是一个结束，也是一个新的开始。在此，我要感谢所有在这个过程中给予我帮助的人们，正是有了你们的支持，我才能完成这个项目，并以此为起点，踏上新的人生旅程。谢谢大家！